"use strict";
/**
 * A Storage implementation backed by the temp folder on the local system. Only intended for testing.
 *
 * Not compatible with browsers. Unrelated (!) to LocalStorage available in browsers.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const url = __importStar(require("url"));
const _1 = require(".");
const readable_stream_1 = require("readable-stream");
const utils_1 = require("../utils");
// Browser-incompatible modules. Import only in NodeJS.
const fs = utils_1.isNode ? require('fs') : undefined;
const tmp = utils_1.isNode ? require('tmp') : undefined;
class LocalStorage {
    constructor() {
        if (!utils_1.isNode) {
            // We could transparently use browser's LocalStorage as a backend
            // in this case. There has been no need for that yet though.
            throw new Error('This class is not compatible with browsers; it needs NodeJS to run.');
        }
    }
    /**
     * "Uploads" `data` to the a temporary file on the local system.
     * @returns the path (URL, starting with file:///) to the uploaded data.
     */
    put(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = tmp.tmpNameSync({ prefix: 'parcel-storage-' });
            return new Promise((resolve, reject) => {
                const dataStream = utils_1.toReadable(data);
                const fileSizer = new _1.FileSizerTransform();
                dataStream
                    .on('error', reject)
                    .pipe(fileSizer)
                    .on('error', reject)
                    .pipe(fs.createWriteStream(path))
                    .on('error', reject)
                    .on('finish', () => {
                    resolve({
                        path: url.pathToFileURL(path).toString(),
                        size: fileSizer.currentFileSize(),
                    });
                });
            });
        });
    }
    /**
     * "Downloads" a single file from the local filesystem.
     * @param path The local URL (file:///...) to fetch
     */
    get(path) {
        if (!path.startsWith('file:///')) {
            throw new Error(`Invalid local storage path: ${path}`);
        }
        const fsPath = url.fileURLToPath(path);
        return new readable_stream_1.Readable().wrap(fs.createReadStream(fsPath));
    }
    sizeOf(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!path.startsWith('file:///')) {
                throw new Error(`Invalid local storage path: ${path}`);
            }
            const fsPath = url.fileURLToPath(path);
            const stats = yield fs.promises.stat(fsPath);
            return BigInt(stats.size);
        });
    }
}
exports.LocalStorage = LocalStorage;
//# sourceMappingURL=local.js.map