"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("../utils");
const _1 = require(".");
exports.PATH_PREFIX = 'parcel://';
class ParcelStorage {
    /** `gatewayUrl` is the Parcel Gateway url stored in `Config`. */
    constructor(gatewayUrl, tokenProvider) {
        this.tokenProvider = tokenProvider;
        this.apiEndpoint = `${gatewayUrl}/storage`; // `Config` ctor strips trailing `/`
    }
    put(data) {
        return __awaiter(this, void 0, void 0, function* () {
            let getFileSize;
            if (utils_1.isUint8Array(data)) {
                const len = BigInt(data.length);
                getFileSize = () => len;
            }
            else {
                const fileSizer = new _1.FileSizerTransform();
                data = data.pipe(fileSizer);
                getFileSize = () => fileSizer.currentFileSize();
            }
            const { data: receipt } = yield axios_1.default.post(`${this.apiEndpoint}/object`, data, {
                headers: Object.assign(yield this.getHeaders(), {
                    'content-type': 'application/octet-stream',
                }),
            });
            return {
                path: exports.PATH_PREFIX + receipt.objectId,
                size: getFileSize(),
            };
        });
    }
    get(path) {
        let objectEndpoint;
        try {
            objectEndpoint = this.getObjectEndpoint(path);
        }
        catch (e) {
            return new readable_stream_1.Readable({
                read() {
                    this.destroy(e);
                },
            });
        }
        const dl = new readable_stream_1.PassThrough();
        const download = (utils_1.isNode ? this.downloadNode : this.downloadBrowser).bind(this);
        this.getHeaders()
            .then((headers) => download(objectEndpoint, headers, dl))
            .catch(dl.destroy.bind(dl));
        return dl;
    }
    downloadNode(objectEndpoint, headers, dl) {
        return __awaiter(this, void 0, void 0, function* () {
            return axios_1.default
                .get(objectEndpoint, {
                responseType: 'stream',
                headers,
            })
                .then((res) => {
                res.data.on('error', dl.destroy.bind(dl)).pipe(dl);
            });
        });
    }
    downloadBrowser(objectEndpoint, headers, dl) {
        return __awaiter(this, void 0, void 0, function* () {
            return fetch(objectEndpoint, {
                method: 'GET',
                headers,
            }).then((res) => __awaiter(this, void 0, void 0, function* () {
                if (!res.body)
                    return dl.end();
                const rdr = res.body.getReader();
                let chunk;
                do {
                    chunk = yield rdr.read();
                    if (!chunk.value)
                        continue;
                    if (!dl.write(chunk.value)) {
                        yield new Promise(dl.once.bind(dl, 'drain'));
                    }
                } while (!chunk.done);
                dl.end();
            }));
        });
    }
    sizeOf(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield axios_1.default.head(this.getObjectEndpoint(path), {
                headers: yield this.getHeaders(),
            });
            return BigInt(res.headers['content-length']);
        });
    }
    /**
     * @returns the endpoint at which the object at `path` can be reached, if the path is valid.
     * @throws an error if the path is not valid.
     */
    getObjectEndpoint(path) {
        if (!path.startsWith(exports.PATH_PREFIX)) {
            throw new Error(`unsupported path for Parcel storage: \`${path}\``);
        }
        const objectId = path.slice(exports.PATH_PREFIX.length);
        return `${this.apiEndpoint}/object/${objectId}`;
    }
    getHeaders() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                authorization: `Bearer ${yield this.tokenProvider.getToken()}`,
            };
        });
    }
}
exports.ParcelStorage = ParcelStorage;
//# sourceMappingURL=parcel.js.map