"use strict";
/**
 * A thin wrapper around the official Google Cloud Storage client that makes it conform
 * to our `Storage` interface.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
const js_sha3_1 = require("js-sha3");
const https_1 = require("https");
const token_1 = require("../token");
const utils_1 = require("../utils");
/**
 * Parses an GCP URI of the format "gs://my_bucket/my_path/to_file.txt" into bucket and
 * path components; or throws an error if the format doesn't match.
 */
function parseGCPUri(gcpUri) {
    const gcpUrlRe = /^[gG][sS]:\/\/(.*?)\/(.*)/;
    const match = gcpUri.match(gcpUrlRe);
    if (!match) {
        throw new Error(`Not a valid GCP URL: ${gcpUri}`);
    }
    return {
        bucket: match[1],
        key: match[2],
    };
}
class GCPStorage {
    constructor(gcpParams) {
        this.gcpParams = gcpParams;
        if (gcpParams.accessToken && gcpParams.keys) {
            throw new Error(`Either GCP API access token or keys need to be defined, not both.`);
        }
    }
    /**
     * Updates the bucket to which future uploads will go.
     */
    setUploadBucket(bucket) {
        this.gcpParams.uploadBucket = bucket;
    }
    /**
     * Returns access token either from keys (token is refreshed, if needed) or a predefined one, if
     * no keys provided.
     */
    getAccessToken() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.gcpParams.keys) {
                // Setup token provider if accessing the token for the first time, or use existing token
                // provider if only refreshing the existing access token.
                if (!this.tokenProvider) {
                    this.tokenProvider = token_1.RenewingTokenProvider.fromPrivatePEM({
                        clientId: (_a = this.gcpParams.keys.client_email) !== null && _a !== void 0 ? _a : this.gcpParams.keys.client_id,
                        clientSecret: this.gcpParams.keys.private_key,
                        tokenEndpoint: this.gcpParams.keys.token_uri,
                        scopes: [token_1.TokenScope.GCP],
                        expiresIn: this.gcpParams.expiresIn,
                    });
                }
                return this.tokenProvider.getToken();
            }
            // Use predefined access token, if no keys set.
            if (!this.gcpParams.accessToken) {
                throw new Error('Cannot obtain access token; aborting.');
            }
            return this.gcpParams.accessToken;
        });
    }
    /**
     * Uploads `data` to the GCP bucket specified in `gcpParams` using a simple POST request. The
     * filename is derived `data` hash (content-addressable storage).
     *
     * @returns the path (URI) to the uploaded data.
     */
    put(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.getAccessToken();
            if (!this.gcpParams.uploadBucket) {
                throw new Error(`Cannot upload data to GCP; the target bucket is not configured. Make sure your Parcel configuration specifies storageBackends.gcpParams.uploadBucket.`);
            }
            const dataBuf = utils_1.isUint8Array(data) ? data : yield utils_1.collectByteStream(data);
            const gcpPath = js_sha3_1.keccak256(dataBuf);
            const gcpUri = `gs://${this.gcpParams.uploadBucket}/${gcpPath}`;
            /* Based on the following curl command:
            curl -X POST --data-binary @[OBJECT_LOCATION] \
                 -H "Authorization: Bearer [OAUTH2_TOKEN]" \
                 -H "Content-Type: [OBJECT_CONTENT_TYPE]" \
                 "https://storage.googleapis.com/upload/storage/v1/b/[BUCKET_NAME]/o?uploadType=media&name=[OBJECT_NAME]"
            */
            const options = {
                hostname: 'storage.googleapis.com',
                port: 443,
                path: `/upload/storage/v1/b/${this.gcpParams.uploadBucket}/o?uploadType=media&name=${gcpPath}`,
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    'Content-Type': 'application/octet-stream',
                    'Content-Length': dataBuf.byteLength,
                },
            };
            yield new Promise((resolve, reject) => {
                const req = https_1.request(options, (res) => {
                    if (!res.statusCode || res.statusCode < 200 || res.statusCode >= 300) {
                        return reject(new Error(`attempt to upload ${dataBuf.byteLength} failed with status \
${res.statusCode} ${res.statusMessage}. Request: ${JSON.stringify(options)}`));
                    }
                    res.on('data', () => undefined);
                    res.on('end', resolve);
                });
                req.on('error', (err) => {
                    reject(new Error(`failed to upload data to ${gcpUri}. Error: ${err.stack}`));
                });
                req.end(dataBuf);
            });
            return {
                path: gcpUri,
                size: BigInt(dataBuf.byteLength),
            };
        });
    }
    /**
     * Downloads a single file from from GCP, synchronously.
     * @param path The GCP URI to fetch, of the form gs://<bucket>/<path>
     */
    get(gcpUri) {
        const res = this.getObject(gcpUri, true /* download */);
        const pt = new readable_stream_1.PassThrough();
        res.then((dl) => {
            dl.on('error', pt.destroy.bind(pt)).pipe(pt);
        }).catch(pt.destroy.bind(pt));
        return pt;
    }
    sizeOf(gcpUri) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getObject(gcpUri, false /* download */);
            const resBody = yield utils_1.collectByteStream(new readable_stream_1.Readable().wrap(res));
            return BigInt(JSON.parse(resBody.toString())['size']);
        });
    }
    getObject(gcpUri, download) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = yield this.makeGetOptions(gcpUri, download);
            return new Promise((resolve, reject) => {
                const req = https_1.request(options, (res) => {
                    if (!res.statusCode || res.statusCode < 200 || res.statusCode >= 300) {
                        return reject(new Error(`Failed to fetch ${options.path}, statusCode=${res.statusCode} ${res.statusMessage}`));
                    }
                    resolve(res);
                });
                req.on('error', reject);
                req.on('abort', reject);
                req.end();
            });
        });
    }
    makeGetOptions(uri, download) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.getAccessToken();
            const { bucket, key } = parseGCPUri(uri);
            // Per https://cloud.google.com/storage/docs/json_api/v1/objects/get:
            return {
                hostname: 'storage.googleapis.com',
                port: 443,
                path: `/storage/v1/b/${bucket}/o/${key}?alt=${download ? 'media' : ''}`,
                method: 'GET',
                headers: {
                    authorization: `Bearer ${accessToken}`,
                },
            };
        });
    }
    /**
     * Deletes a single file from from GCP.
     * @param path The GCP URI to delete, of the form gs://<bucket>/<path>
     */
    delete(gcpUri) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield this.getAccessToken();
            if (!this.gcpParams.uploadBucket) {
                throw new Error(`Cannot delete data from GCP; the target bucket is not configured. Make sure your Parcel configuration specifies storageBackends.gcpParams.uploadBucket.`);
            }
            const { bucket, key } = parseGCPUri(gcpUri);
            /* Based on the following curl command:
            curl -X DELETE \
                 -H "Authorization: Bearer [OAUTH2_TOKEN]" \
                 "https://storage.googleapis.com/storage/v1/b/[BUCKET]/o/[OBJECT]'"
            */
            const options = {
                hostname: 'storage.googleapis.com',
                port: 443,
                path: `/storage/v1/b/${bucket}/o/${key}`,
                method: 'DELETE',
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            };
            return new Promise((resolve, reject) => {
                const req = https_1.request(options, (res) => {
                    if (!res.statusCode || res.statusCode < 200 || res.statusCode >= 300) {
                        return reject(new Error(`Attempt to delete ${key} from bucket ${bucket} resulted in \
statusCode ${res.statusCode} ${res.statusMessage}. Request: ${JSON.stringify(options)}`));
                    }
                    resolve();
                });
                req.on('error', reject);
                req.on('abort', reject);
                req.end();
            });
        });
    }
}
exports.GCPStorage = GCPStorage;
//# sourceMappingURL=gcp.js.map