"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const readable_stream_1 = require("readable-stream");
const uuid_1 = require("uuid");
const axios_1 = __importDefault(require("axios"));
const depd_1 = __importDefault(require("depd"));
exports.isNode = typeof process !== 'undefined' && !!((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node);
const MAX_RETRIES = 10;
exports.deprecate = depd_1.default('parcel-sdk');
class DontRetryError extends Error {
    constructor(message) {
        super(message); // 'Error' breaks prototype chain here
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
    }
}
exports.DontRetryError = DontRetryError;
class UnindexedObjectError extends Error {
    constructor(message) {
        super(message); // 'Error' breaks prototype chain here
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
    }
}
exports.UnindexedObjectError = UnindexedObjectError;
/**
 * Queries the indexer for information about a dataset at `serviceAddress`.
 *
 * The view of state seen by the indexer slightly lags that of the gateway
 * (which lags that of the consensus layer). Thus, if the indexer returns
 * "no data" but the gateway reports that the dataset exists, this function
 * will retry until the indexer has taken note of the same.
 *
 * @returns the decoded JSON object returned by the indexer for the requested `method`.
 */
function queryIndex(method, serviceAddress, indexerUrl, oasisGateway, tokenProvider, payload, log, { INDEXER_RETRY_INTERVAL_MS = 1000 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const queryUrl = `${indexerUrl}/${method}`;
        const doFetch = () => __awaiter(this, void 0, void 0, function* () {
            return yield axios_1.default
                .post(queryUrl, payload, {
                headers: {
                    authorization: 'Bearer ' + (yield tokenProvider.getToken()),
                    'content-type': 'application/json',
                    'X-Request-ID': uuid_1.v4(),
                },
                validateStatus: (status) => status === 200,
            })
                .then((res) => res.data)
                .catch((err) => {
                const res = err.response;
                if (!res) {
                    // Retry if indexer sometimes rejects a request in browser (CORS).
                    // (can't capture a specific error because of different browsers)
                    log === null || log === void 0 ? void 0 : log.warn({ err, payload, queryUrl }, `Error while querying the indexer.`);
                    throw err;
                }
                const errMsg = typeof res.data === 'string' ? res.data : JSON.stringify(res.data);
                // Retry if indexer returns empty response (not yet indexed).
                if (res.status === 204 || res.status === 404) {
                    throw new UnindexedObjectError(`Unknown indexer object (HTTP ${res.status}); queried ${indexerUrl} with ${JSON.stringify(payload)}`);
                }
                // Retry if indexer sometimes rejects a request in NodeJS (no CORS).
                if (res.status === 502) {
                    log === null || log === void 0 ? void 0 : log.warn({ payload, queryUrl }, `Indexer returned HTTP 502: ${errMsg}`);
                    throw new Error(errMsg);
                }
                // Don't retry on other error responses.
                throw new DontRetryError(`could not query indexer for service ${serviceAddress.hex}: HTTP ${res.status} ${errMsg}`);
            });
        });
        const doRetry = (retries = 1) => __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setTimeout(resolve, INDEXER_RETRY_INTERVAL_MS));
            try {
                return yield doFetch();
            }
            catch (e) {
                if (retries >= MAX_RETRIES)
                    throw e;
                if (e instanceof DontRetryError)
                    throw e;
                return yield doRetry(retries + 1);
            }
        });
        try {
            log === null || log === void 0 ? void 0 : log.trace({ payload, queryUrl }, `Querying indexer at ${queryUrl}`);
            return yield doFetch();
        }
        catch (err) {
            try {
                yield oasisGateway.getCode(serviceAddress);
            }
            catch (_a) {
                throw new DontRetryError(`no service at ${serviceAddress.hex}: ${err}`);
            }
            return yield doRetry();
        }
    });
}
exports.queryIndex = queryIndex;
function unreachable(type, errMsg) {
    throw new Error(errMsg);
}
exports.unreachable = unreachable;
function collectByteStream(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.on('readable', () => {
            let chunk;
            while (null !== (chunk = stream.read())) {
                chunks.push(chunk);
            }
        });
        stream.on('end', () => {
            resolve(buffer_1.Buffer.concat(chunks));
        });
        stream.on('error', reject);
    });
}
exports.collectByteStream = collectByteStream;
function intoByteStream(bytes) {
    const bytesPromise = Promise.resolve(bytes);
    return new readable_stream_1.Readable({
        read(_size) {
            bytesPromise
                .then((bytes) => {
                if (process.env.NODE_ENV === 'test') {
                    // work around https://github.com/facebook/jest/issues/4422
                    bytes = buffer_1.Buffer.from(bytes);
                }
                this.push(bytes);
                this.push(null);
            })
                .catch((e) => this.destroy(e));
        },
    });
}
exports.intoByteStream = intoByteStream;
function toReadable(input) {
    if (isUint8Array(input)) {
        return intoByteStream(input);
    }
    else if (isPromise(input)) {
        return intoByteStream(input.then((arr) => (isUint8Array(arr) ? arr : new Uint8Array(arr))));
    }
    else {
        return input;
    }
}
exports.toReadable = toReadable;
/** Returns whether the input is a `Uint8Array` (or a `Buffer`). */
function isUint8Array(input) {
    return (input instanceof Uint8Array ||
        buffer_1.Buffer.isBuffer(input) ||
        input.constructor.name === Uint8Array.name);
}
exports.isUint8Array = isUint8Array;
/**
 * Returns whether the input is a `Promise`. This function exists to avoid the ridiculous
 * import syntax of `p-is-promise` [0].
 * [0]: https://github.com/sindresorhus/p-is-promise/releases/tag/v3.0.0
 */
function isPromise(input) {
    return (input instanceof Promise ||
        (input && typeof input.then === 'function' && typeof input.catch === 'function'));
}
exports.isPromise = isPromise;
//# sourceMappingURL=utils.js.map