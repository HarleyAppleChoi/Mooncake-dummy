import { Address, DeployOptions, Gateway, Result, RpcError, RpcOptions, Set } from 'oasis-std';
import * as identity from '../service-clients/identity';
import { Config } from '../config';
import { Dataset, Policy } from '../data';
export { BlanketPolicyChanged, // DEPRECATED: events will be removed in a future release
BlanketPolicyFilter, BlanketPolicyParams, Error as IdentityError, IdentityDeactivated, // DEPRECATED: events will be removed in a future release
InvocationError, } from '../service-clients/identity';
/**
 * A Identity is a user account on Oasis. It's provides a consistent identity across multiple
 * devices, and can be used to interact with other services.
 *
 * At its core, a Identity is a secret key that is usable, but not visible to the user (c.f. sudo).
 * This design establishes a root of trust in the code of the Identity. Additionally, it enables
 * the creation of self-sovereign identities that act on behalf of zero or more parties.
 *
 * The `Identity` interface is designed to allow a user to assume the role of a Identity.
 * The Identity can be also be accessed directly using the oasis.js `Service.at` method;
 *
 * ## Interaction with Identity Items
 *
 * A identity item is something that is operable by the identity. For instance, a Dataset
 * has its metadata managed by a identity. Generally, identity items exist as on-chain pointers
 * to off-chain data. The blockchain records policies, root hashes, and essential metadata.
 *
 * A newly created (or transferred) item can notify the user of its existence by emitting an
 * event. The user will rely on an indexer to deliver the event to their device. The user can
 * then choose to record that in their folio (off-chain). The presentational metadata not stored
 * anywhere. This gives the application and user the ability to decide on price vs durability.
 */
export declare class Identity {
    private client;
    private pubState;
    private config;
    address: Address;
    trustedSenders: Set<Address>;
    active: boolean;
    creationTimestamp: Date;
    deactivationTimestamp: Date;
    /** A `Gateway` that tunnels deploys and RPCs through this Identity. */
    proxy: Gateway;
    private constructor();
    /**
     * Connects to an existing Identity service located at the provided address.
     *
     * @throws if the used gateway api token does not have permissions over the identity
     * @returns a client to the connected Identity.
     */
    static connect(address: Address, config: Config, { useCache }?: {
        useCache?: boolean | undefined;
    }): Promise<Identity>;
    /**
     * Returns the address of the identity that is associated with the given access token.
     * In typical Parcel use, the token is obtained with `Config.tokenProvider.getToken()`.
     **/
    static addressFromToken(accessToken: string): Address;
    /**
     * Deploys a new service through this identity (sets `ctx.sender()` to `this.address`).
     * @throws an `RpcError` if the deploy fails
     * @returns the output of the create call.
     */
    spawn(payload: Uint8Array, options?: DeployOptions): Promise<Result<Address, RpcError>>;
    /**
     * Invokes a service using the authority of this identity.
     * This is a fairly low-level call that simply calls the `invoke` RPC method.
     * @throws an `RpcError` if the RPC fails
     * @returns whatever the invoked method returns (usually ABI-encoded types).
     */
    invoke(address: Address, payload: Uint8Array, options?: RpcOptions): Promise<Result<Uint8Array, RpcError>>;
    /**
     * @returns the datasets owned by this identity
     */
    getOwnedDatasets(): Promise<Dataset[]>;
    /**
     * @returns the datasets shared with this identity
     */
    getSharedDatasets(): Promise<Dataset[]>;
    /**
     * @returns the datasets created by this identity
     */
    getCreatedDatasets(): Promise<Dataset[]>;
    /**
     * @returns datasets that match the provided dataset type
     */
    private getDatasets;
    /**
     * Adds a pre-grant to this identity. When a dataset is created, it will call the
     * owning identity to get its initial policy depending on which filter it matches.
     * Filter matching is in order of specificity (i.e. how many non-None fields are matched)
     * and then priority.
     */
    addBlanketPolicy<T>(filter: identity.BlanketPolicyFilter, policy: Policy<T>, memo: Uint8Array): Promise<void>;
    /** Removes an existing pre-grant by its filter, which must match exactly. */
    removeBlanketPolicy(filter: identity.BlanketPolicyFilter): Promise<void>;
    /**
     * Get the trusted senders for this Identity.
     */
    resetTrustedSenders(newTrustedSenders: Set<Address>): Promise<void>;
    /**
     * Marks this Identity as inactive. It will no longer respond to external events.
     * This is currently permanent, so if you want to change identities, you'll have to
     * migrate your data.
     */
    deactivate(): Promise<void>;
    /** Human-readable information about the object's core properties */
    debugString(): Promise<string>;
}
