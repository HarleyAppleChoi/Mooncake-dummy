"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const oasis_std_1 = require("oasis-std");
const identity = __importStar(require("../service-clients/identity"));
const data_1 = require("../data");
var identity_1 = require("../service-clients/identity");
exports.BlanketPolicyChanged = identity_1.BlanketPolicyChanged;
exports.BlanketPolicyFilter = identity_1.BlanketPolicyFilter;
exports.BlanketPolicyParams = identity_1.BlanketPolicyParams;
exports.IdentityError = identity_1.Error;
exports.IdentityDeactivated = identity_1.IdentityDeactivated;
exports.InvocationError = identity_1.InvocationError;
const utils_1 = require("../utils");
/**
 * A Identity is a user account on Oasis. It's provides a consistent identity across multiple
 * devices, and can be used to interact with other services.
 *
 * At its core, a Identity is a secret key that is usable, but not visible to the user (c.f. sudo).
 * This design establishes a root of trust in the code of the Identity. Additionally, it enables
 * the creation of self-sovereign identities that act on behalf of zero or more parties.
 *
 * The `Identity` interface is designed to allow a user to assume the role of a Identity.
 * The Identity can be also be accessed directly using the oasis.js `Service.at` method;
 *
 * ## Interaction with Identity Items
 *
 * A identity item is something that is operable by the identity. For instance, a Dataset
 * has its metadata managed by a identity. Generally, identity items exist as on-chain pointers
 * to off-chain data. The blockchain records policies, root hashes, and essential metadata.
 *
 * A newly created (or transferred) item can notify the user of its existence by emitting an
 * event. The user will rely on an indexer to deliver the event to their device. The user can
 * then choose to record that in their folio (off-chain). The presentational metadata not stored
 * anywhere. This gives the application and user the ability to decide on price vs durability.
 */
class Identity {
    constructor(client, pubState, config) {
        this.client = client;
        this.pubState = pubState;
        this.config = config;
        this.creationTimestamp = new Date(0);
        this.deactivationTimestamp = new Date(0);
        this.address = client.address;
        this.active = pubState.active;
        this.trustedSenders = pubState.trustedSenders;
        this.proxy = createGatewayProxy(this.config.oasisGateway, new IdentityTunnel(this));
    }
    // ^ private because `new Identity` belies the high cost of the operation
    /**
     * Connects to an existing Identity service located at the provided address.
     *
     * @throws if the used gateway api token does not have permissions over the identity
     * @returns a client to the connected Identity.
     */
    static connect(address, config, { useCache = true } = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // See if we can reuse the pre-connected Identity from `config`.
            if (useCache && address.equals((yield config.getTokenIdentity()).address)) {
                config.log.debug({ address: address.hex }, 'Reusing pre-connected Identity');
                return config.getTokenIdentity();
            }
            const client = yield identity.Identity.connect(address, config.oasisGateway);
            let connectedIdentity;
            try {
                const res = yield utils_1.queryIndex('identity/getIdentityPublicState', address, config.indexerUrl, config.oasisGateway, config.tokenProvider, {
                    identity: address.hex,
                }, config.log);
                connectedIdentity = new Identity(client, new identity.PublicState({
                    trustedSenders: new oasis_std_1.Set((_a = res.trustedSenders) === null || _a === void 0 ? void 0 : _a.map((senderAddress) => new oasis_std_1.Address(senderAddress))),
                    blanketPolicies: [],
                    active: res.active,
                }), config);
                // Assign out-of-band attributes.
                connectedIdentity.creationTimestamp = new Date(res.creationTimestamp * 1000);
                connectedIdentity.deactivationTimestamp = new Date(res.deactivationTimestamp * 1000);
            }
            catch (err) {
                config.log.warn({ err }, `Failed to get public state for identity ${address.hex} from the index. Querying the chain instead.`);
                connectedIdentity = new Identity(client, yield client.getPublicState(), config);
            }
            return connectedIdentity;
        });
    }
    /**
     * Returns the address of the identity that is associated with the given access token.
     * In typical Parcel use, the token is obtained with `Config.tokenProvider.getToken()`.
     **/
    static addressFromToken(accessToken) {
        try {
            return new oasis_std_1.Address(JSON.parse(Buffer.from(accessToken.split('.')[1], 'base64').toString())['sub']);
        }
        catch (err) {
            throw new Error(`Could not parse address from the \`sub\` field of access token "${accessToken}". Either the token is not a valid JWT, or the \`sub\` field is not a valid identity address.`);
        }
    }
    /**
     * Deploys a new service through this identity (sets `ctx.sender()` to `this.address`).
     * @throws an `RpcError` if the deploy fails
     * @returns the output of the create call.
     */
    spawn(payload, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const deployCode = oasis_std_1.Gateway.makeDeployCode(payload, options);
            return this.client.spawn({ deployCode: new identity.DeployCode(deployCode) });
        });
    }
    /**
     * Invokes a service using the authority of this identity.
     * This is a fairly low-level call that simply calls the `invoke` RPC method.
     * @throws an `RpcError` if the RPC fails
     * @returns whatever the invoked method returns (usually ABI-encoded types).
     */
    invoke(address, payload, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.invoke({ serviceAddr: address, message: payload }, options);
        });
    }
    /**
     * @returns the datasets owned by this identity
     */
    getOwnedDatasets() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getDatasets(true /* owned */);
        });
    }
    /**
     * @returns the datasets shared with this identity
     */
    getSharedDatasets() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getDatasets(false /* not owned */);
        });
    }
    /**
     * @returns the datasets created by this identity
     */
    getCreatedDatasets() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield utils_1.queryIndex('identity/getCreatedDatasets', this.address, this.config.indexerUrl, this.config.oasisGateway, this.config.tokenProvider, {
                    identity: this.address.hex,
                }, this.config.log);
                return Promise.all(res.datasets.map((dataset) => {
                    return data_1.Dataset.connect(new oasis_std_1.Address(dataset.address), this, this.config);
                }));
            }
            catch (err) {
                this.config.log.warn({ err }, `Failed to fetch created datasets for Identity ${this.address.hex} from indexer. Returning empty list as fallback.`);
                return [];
            }
        });
    }
    /**
     * @returns datasets that match the provided dataset type
     */
    getDatasets(owned) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield utils_1.queryIndex('identity/getDatasets', this.address, this.config.indexerUrl, this.config.oasisGateway, this.config.tokenProvider, {
                    identity: this.address.hex,
                    owned,
                }, this.config.log);
                return Promise.all(res.datasets.map((dataset) => {
                    return data_1.Dataset.connect(new oasis_std_1.Address(dataset.address), this, this.config);
                }));
            }
            catch (err) {
                this.config.log.warn({ err }, `Failed to fetch datasets for Identity ${this.address.hex} from indexer. Returning empty list as fallback.`);
                return [];
            }
        });
    }
    /**
     * Adds a pre-grant to this identity. When a dataset is created, it will call the
     * owning identity to get its initial policy depending on which filter it matches.
     * Filter matching is in order of specificity (i.e. how many non-None fields are matched)
     * and then priority.
     */
    addBlanketPolicy(filter, policy, memo) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.addBlanketPolicy({ filter, policy: policy.address, memo });
        });
    }
    /** Removes an existing pre-grant by its filter, which must match exactly. */
    removeBlanketPolicy(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.removeBlanketPolicy({ filter });
        });
    }
    /**
     * Get the trusted senders for this Identity.
     */
    resetTrustedSenders(newTrustedSenders) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.resetTrustedSenders({ newTrustedSenders });
            this.trustedSenders = newTrustedSenders;
        });
    }
    /**
     * Marks this Identity as inactive. It will no longer respond to external events.
     * This is currently permanent, so if you want to change identities, you'll have to
     * migrate your data.
     */
    deactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deactivate();
            this.active = false;
            this.deactivationTimestamp = new Date();
        });
    }
    /** Human-readable information about the object's core properties */
    debugString() {
        return __awaiter(this, void 0, void 0, function* () {
            let dbg = `Identity${this.active ? '' : ' (DEACTIVATED)'} at ${this.address.hex}
  Trusted senders:`;
            for (const addr of Array.from(this.trustedSenders.values())) {
                dbg += `    ${addr.hex}\n`;
            }
            return dbg.trim();
        });
    }
}
exports.Identity = Identity;
function createGatewayProxy(gateway, hooks) {
    return new Proxy(gateway, {
        get: (target, prop) => {
            var _a;
            return (_a = hooks[prop]) !== null && _a !== void 0 ? _a : target[prop];
        },
    });
}
/**
 * Gateway hooks that tunnel deploys and RPCs through the Identity service so to have the
 * transaction `sender` be the Identity service's address.
 */
class IdentityTunnel {
    constructor(identity) {
        this.identity = identity;
    }
    deploy(payload, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return IdentityTunnel.unwrapOrThrow(yield this.identity.spawn(payload, options));
        });
    }
    rpc(address, payload, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return IdentityTunnel.unwrapOrThrow(yield this.identity.invoke(address, payload, options));
        });
    }
    static unwrapOrThrow(res) {
        if (res.isOk()) {
            return res.unwrap();
        }
        throw res.unwrapErr();
    }
}
//# sourceMappingURL=identity.js.map