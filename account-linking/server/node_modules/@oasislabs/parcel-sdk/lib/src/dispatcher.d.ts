import { Address, RpcOptions } from 'oasis-std';
import * as dispatcher from './service-clients/dispatcher';
import { Config } from './config';
import { DatasetCipher } from './data/dataset';
import { Identity } from './identity';
import { Policy } from './data/policy';
export { DatasetRequestError, Error as DispatcherError, JobCompleted, // DEPRECATED: events will be removed in a future release
JobCompletionStatus, Secrets, } from './service-clients/dispatcher';
export declare type JobInfo = {
    status: dispatcher.JobCompletionStatus;
    outputs: JobInfo.OutputDataset[];
    info: string;
};
export declare namespace JobInfo {
    type OutputDataset = {
        mountPath: string;
        address: Address;
    };
}
export declare class Dispatcher {
    private client;
    private config;
    readonly address: Address;
    private constructor();
    /** Connect to an existing dispatcher at `address` using the authority of `identity`. **/
    static connect(address: Address, identity: Identity, config: Config): Promise<Dispatcher>;
    /** Create a new Dispatcher, owned by `executor`. **/
    static deploy(executor: Identity, config: Config): Promise<Dispatcher>;
    /**
     * Fetches additional info about job request `job` from the dispatcher.
     *
     * Implementation note:
     * To keep the dispatcher ABI stable, most info about the job is JSON-serialized inside the `userSecret` field at
     * the Rust level. This unfortunately means somewhat more boilerplate here to carefully parse that JSON.
     **/
    augmentJobRequest(job: JobRequestLite): Promise<JobRequestFull>;
    /** Returns information (notably, the completion status and output datasets)
     * for a job that was previously submitted to this Dispatcher. Throws if the
     * job ID does not exist. **/
    getJobInfo(jobId: Uint8Array): Promise<JobInfo>;
    /**
     * Same as `getJobInfo()`, but the return Promise does not resolve until the
     * job has finished executing. While waiting for the job to complete, this
     * function will check its status every `pollIntervalSeconds`, for a maximum
     * duration of `timeoutSeconds`.
     **/
    getCompletedJobInfo(jobId: Uint8Array, pollIntervalSeconds?: number, timeoutSeconds?: number): Promise<JobInfo>;
    /** Human-readable information about the object's core properties */
    debugString(): Promise<string>;
    submitJob({ job }: {
        job: JobRequest;
    }, options?: RpcOptions): Promise<Uint8Array>;
    /**
     * Returns all pending jobs. If `jobIds` is set, returns only those with matching ids.
     * This method is ideally called with `jobIds` after appropriately subsetting the ids
     * returned by `getPendingJobIds` to avoid going over the gas limit.
     */
    getPendingJobs(kwargs?: {
        jobIds?: Uint8Array[];
    }): Promise<JobRequestLite[]>;
    /**
     * Marks job `jobId` as complete, with status `status` and having produced
     * `outputs`. `info` is additional human-readable information about the
     * `status`, intended especially for the case of errors.
     *
     * This method is intended to be called only by the offchain worker. Unless
     * you are developing the Parcel stack itself, you probably od not need this
     * method.
     **/
    completeJob({ jobId, status, outputs, info, }: {
        jobId: Uint8Array;
        status: dispatcher.JobCompletionStatus;
        outputs: JobInfo.OutputDataset[];
        info: string;
    }): Promise<void>;
    getPendingJobIds: (options?: RpcOptions | undefined) => Promise<Uint8Array[]>;
    getQuota: (options?: RpcOptions | undefined) => Promise<number>;
    increaseQuota: ({ entity, amount }: {
        entity: Address;
        amount: number;
    }, options?: RpcOptions | undefined) => Promise<void>;
    getQuotaOf: ({ entity }: {
        entity: Address;
    }, options?: RpcOptions | undefined) => Promise<number>;
    deactivate: (options?: RpcOptions | undefined) => Promise<void>;
}
export declare type JobRequest = {
    name: string;
    cmd: string[];
    dockerImage?: string;
    env?: {
        [key: string]: string;
    };
    inputDatasets?: JobRequest.InputDataset[];
    outputDatasets?: JobRequest.OutputDataset[];
};
export declare namespace JobRequest {
    type InputDataset = {
        mountPath: string;
        address: Address;
    };
    type OutputDataset = {
        mountPath: string;
        owner: Identity;
        policy?: Policy<any>;
    };
}
export declare type JobRequestLite = {
    id: Uint8Array;
    name: string;
    requestedDatasets: Address[];
};
export declare type JobRequestFull = {
    id: Uint8Array;
    name: string;
    cmd: string[];
    dockerImage?: string;
    env: {
        [key: string]: string;
    };
    inputDatasets: JobRequestFull.InputDataset[];
    outputDatasets: JobRequestFull.OutputDataset[];
    datasetCiphers: Map<string, DatasetCipher>;
    submitterConfig: Config;
};
export declare namespace JobRequestFull {
    type InputDataset = {
        mountPath: string;
        localPath?: string;
        address: Address;
    };
    type OutputDataset = {
        mountPath: string;
        localPath?: string;
        owner: Address;
        policy?: Address;
    };
}
