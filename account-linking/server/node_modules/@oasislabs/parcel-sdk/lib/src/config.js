"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const oasis_std_1 = require("oasis-std");
const storage_1 = require("./storage");
const identity_1 = require("./identity/identity");
const local_1 = require("./storage/local");
const token_1 = require("./token");
const utils_1 = require("./utils");
/** The default Parcel Gateway, used if the calling client does not specify their own. */
exports.DEFAULT_GATEWAY_URL = 'https://parcel-sdk.oasiscloud.io';
/** The default OAuth token endpoint, used if the calling client does not specify their own. */
exports.DEFAULT_TOKEN_ENDPOINT = 'https://auth.oasiscloud.io/oauth/token';
/** The default dispatcher used to dispatch jobs, used if the calling client does not specify their own. */
// AWS_PROFILE=ops-production-developer-full chamber read production/gcp/us-west2/data-sovereignty oasis_trusted_dispatcher_address
exports.DEFAULT_DISPATCHER_ADDRESS = new oasis_std_1.Address('0x17d10492376bdfcfba74c22ded8166c25acbcf19');
/**
 * `Config` is expected by other classes in this library, like `Identity` and `Dataset`.
 * The same `Config` (singleton) would ideally be used throughout the entire application.
 */
class Config {
    /**
     * @returns a new `Config` with the specified parameters.
     */
    constructor(params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.params = params;
        this.storageBackends = {};
        this.log = oasis_std_1.oasisLogger('parcel-sdk');
        let tokenProvider;
        if (params.apiTokenSigner) {
            const { clientId, privateKey, tokenEndpoint } = params.apiTokenSigner;
            const scopes = [token_1.TokenScope.Api, token_1.TokenScope.Storage];
            tokenProvider = token_1.RenewingTokenProvider.fromPrivateJWK({
                clientId,
                privateKey,
                tokenEndpoint: tokenEndpoint !== null && tokenEndpoint !== void 0 ? tokenEndpoint : exports.DEFAULT_TOKEN_ENDPOINT,
                scopes,
            });
        }
        else if (params.apiAccessToken) {
            tokenProvider = new token_1.StaticTokenProvider(params.apiAccessToken);
        }
        else {
            throw new Error('one of `apiAccessToken` or `apiTokenSigner` must be specified');
        }
        this.tokenProvider = tokenProvider;
        const gatewayUrl = ((_a = params.gatewayUrl) !== null && _a !== void 0 ? _a : exports.DEFAULT_GATEWAY_URL).replace(/\/$/, '');
        this.gatewayUrl = gatewayUrl;
        this.indexerUrl = `${gatewayUrl}/api/state`;
        this.oasisGateway = new oasis_std_1.Gateway(`${gatewayUrl}/oasis`, 'unused api token');
        const gatewaySubscribe = oasis_std_1.Gateway.prototype.subscribe;
        this.oasisGateway.subscribe = (address, topics, decoder, filter = (_) => true) => {
            utils_1.deprecate('event subscriptions will be replaced by explicit state queries');
            return gatewaySubscribe.call(this.oasisGateway, address, topics, decoder, filter);
        };
        const httpGateway = this.oasisGateway['inner'];
        httpGateway.session = new Proxy(httpGateway.session, {
            get(session, prop) {
                if (prop !== 'request')
                    return session[prop];
                return (method, api, body) => __awaiter(this, void 0, void 0, function* () {
                    const token = yield tokenProvider.getToken();
                    session.headers.headers.set('authorization', 'Bearer ' + token);
                    return session.request(method, api, body);
                });
            },
        });
        this.storageConfig = params.storageBackends || {};
        this.storageBackends.parcel = new storage_1.ParcelStorage(gatewayUrl, tokenProvider);
        if ((_b = params.storageBackends) === null || _b === void 0 ? void 0 : _b.s3Params) {
            this.storageBackends.s3 = new storage_1.S3Storage((_c = params.storageBackends) === null || _c === void 0 ? void 0 : _c.s3Params);
        }
        if ((_d = params.storageBackends) === null || _d === void 0 ? void 0 : _d.gcpParams) {
            this.storageBackends.gcp = new storage_1.GCPStorage((_e = params.storageBackends) === null || _e === void 0 ? void 0 : _e.gcpParams);
        }
        if ((_f = params.storageBackends) === null || _f === void 0 ? void 0 : _f.localStorageParams) {
            this.storageBackends.local = new local_1.LocalStorage();
        }
        this.defaultUploadBackend = this.storageBackends[(_h = (_g = params.storageBackends) === null || _g === void 0 ? void 0 : _g.uploadBackend) !== null && _h !== void 0 ? _h : 'parcel'];
        this.dispatcherAddress = (_j = params.dispatcherAddress) !== null && _j !== void 0 ? _j : exports.DEFAULT_DISPATCHER_ADDRESS;
    }
    /**
     * @returns a new `Config` derived from environment variables.
     */
    static paramsFromEnv() {
        var _a;
        if (!(process.env.OASIS_API_ACCESS_TOKEN ||
            (process.env.OASIS_CLIENT_ID && process.env.OASIS_API_PRIVATE_KEY))) {
            throw new Error('To initialize Parcel, you must set one of:\n\t• OASIS_CLIENT_ID and OASIS_API_PRIVATE_KEY\n\t• OASIS_API_ACCESS_TOKEN\nas environment variables.');
        }
        const defaultUploadBackend = (_a = process.env.OASIS_DATA_UPLOAD_BACKEND) !== null && _a !== void 0 ? _a : 'parcel';
        const hasS3 = !!(process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY);
        const hasGCP = !!process.env.GCP_API_ACCESS_TOKEN;
        let apiTokenSigner;
        if (process.env.OASIS_CLIENT_ID && process.env.OASIS_API_PRIVATE_KEY) {
            apiTokenSigner = {
                clientId: process.env.OASIS_CLIENT_ID,
                privateKey: process.env.OASIS_API_PRIVATE_KEY,
                tokenEndpoint: process.env.OASIS_OAUTH_TOKEN_ENDPOINT,
            };
        }
        return {
            gatewayUrl: process.env.PARCEL_GATEWAY_URL,
            apiAccessToken: process.env.OASIS_API_ACCESS_TOKEN,
            apiTokenSigner,
            dispatcherAddress: process.env.DISPATCHER_ADDRESS
                ? new oasis_std_1.Address(process.env.DISPATCHER_ADDRESS)
                : undefined,
            storageBackends: {
                uploadBackend: defaultUploadBackend,
                s3Params: hasS3
                    ? {
                        uploadBucket: process.env.OASIS_S3_UPLOAD_BUCKET,
                        awsAccessKeyId: process.env.AWS_ACCESS_KEY_ID,
                        awsSecretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
                    }
                    : undefined,
                gcpParams: hasGCP
                    ? {
                        accessToken: process.env.GCP_API_ACCESS_TOKEN,
                        keys: process.env.GCP_API_KEYS
                            ? JSON.parse(process.env.GCP_API_KEYS)
                            : undefined,
                    }
                    : undefined,
                localStorageParams: utils_1.isNode ? {} : undefined,
            },
        };
    }
    /**
     * @returns the Identity connected to the authentication token.
     */
    getTokenIdentity() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connectedIdentity) {
                const token = yield this.tokenProvider.getToken();
                const address = identity_1.Identity.addressFromToken(token);
                this.connectedIdentity = identity_1.Identity.connect(address, this, { useCache: false });
            }
            return this.connectedIdentity;
        });
    }
    /**
     * @returns the storage backend for the provided `path`
     */
    storageBackendForPath(path) {
        let backend;
        if (path.startsWith('parcel://')) {
            backend = this.storageBackends.parcel;
        }
        else if (path.startsWith('s3://')) {
            backend = this.storageBackends.s3;
        }
        else if (path.startsWith('gs://')) {
            backend = this.storageBackends.gcp;
        }
        else if (path.startsWith('file://')) {
            backend = this.storageBackends.local;
        }
        else {
            throw new Error(`Unsupported storage path: \`${path}\``);
        }
        if (!backend) {
            throw new Error(`No storage backend configured for \`${path}\``);
        }
        return backend;
    }
}
exports.Config = Config;
//# sourceMappingURL=config.js.map