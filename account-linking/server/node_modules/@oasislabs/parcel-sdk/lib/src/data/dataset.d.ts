import { Address } from 'oasis-std';
import { Readable } from 'readable-stream';
import * as dataset from '../service-clients/dataset';
import { Config } from '../config';
import { Identity } from '../identity';
export { AccessRequested as DatasetAccessRequested, // DEPRECATED: events will be removed in a future release
Cipher as DatasetCipher, DatasetCreated, // DEPRECATED: events will be removed in a future release
DatasetDeactivated, // DEPRECATED: events will be removed in a future release
DispatcherChanged as DatasetDispatcherChanged, // DEPRECATED: events will be removed in a future release
Error as DatasetError, Metadata as DatasetMetadata, OwnerChanged as DatasetOwnerChanged, // DEPRECATED: events will be removed in a future release
PolicyChanged as DatasetPolicyChanged, } from '../service-clients/dataset';
import { Storable, Storage } from '../storage';
import { Policy } from './policy';
declare type DatasetCreateOptions = {
    storage?: Storage;
    creator?: Identity;
    policy?: Policy<any>;
};
/**
 * A dataset is a service that points to off-chain data.
 * This interface is intended for both dataset owners and consumers.
 */
export declare class Dataset {
    private client;
    private pubState;
    private config;
    address: Address;
    metadata: dataset.Metadata;
    creator: Address;
    owner: Address;
    policy?: Address;
    active: boolean;
    creationTimestamp: Date;
    deactivationTimestamp: Date;
    private constructor();
    /**
     * Connects to an existing Dataset service using the authority of the provided identity.
     * If `forceChainLookup` is given, fetches the info from the blockchain, skipping the
     * indexer. This is more costly but guaranteed to have the latest data.
     * WARNING - if `forceChainLookup` is used, the `creationTimestamp` and
     *           `deactivationTimestamp` will not be set on the returned object.
     * @returns a client to the newly-created Dataset that inherits its capabilities from
     *          the identity.
     */
    static connect(address: Address, identity: Identity, config: Config, forceChainLookup?: boolean): Promise<Dataset>;
    /**
     * Creates a new Dataset from un-encrypted data.
     * This will:
     * 1. encrypt the data using a new, random key
     * 2. upload the data to `storage` (if `undefined`, defers to `config.storages`)
     * 3. create a new Dataset service containing the pointer to data and its key
     * @returns a client to the newly-created Dataset
     */
    static upload(data: Storable, metadata: {
        title: string;
        metadataUrl?: string;
    }, owner: Identity, config: Config, opts?: DatasetCreateOptions, cipher?: dataset.Cipher): Promise<Dataset>;
    /**
     * Like `upload` but from maybe-unencrypted data. If it's already encrypted, you'll want to
     * specify `encryptionKey` so that it can be sent to the Dataset service.
     * @returns a client to the newly-created Dataset
     */
    static uploadRaw(cipher: dataset.Cipher, data: Storable, metadata: {
        title: string;
        metadataUrl?: string;
    }, owner: Identity, config: Config, opts?: DatasetCreateOptions): Promise<Dataset>;
    /**
     * Creates a new Dataset service that points at pre-existing data.
     * For an encrypted dataset, you should `encryptionKey` so that the
     * service can grant access to the data.
     * @returns the newly-created Dataset
     */
    static createFromExistingData(cipher: dataset.Cipher, metadata: dataset.Metadata, owner: Identity, config: Config, opts?: DatasetCreateOptions): Promise<Dataset>;
    /**
     * Returns the dataset encryption key, if all policies are satisfied.
     * @throws if the Identity does not have permission to retrieve the key.
     */
    requestAccess(): Promise<dataset.Cipher>;
    /**
     * Returns the log of access requests to this dataset.
     * @throws if the identity does not have permission to read the access log
     */
    getAccessLog(): Promise<AccessLog>;
    /**
     * Get decrypted data from dataset.
     * This will:
     * 1. request access to the dataset's encryption key (unless given as `cipher`)
     * 2. fetch data from storage
     * 3. decrypt it
     */
    download(cipher?: dataset.Cipher): Readable;
    /**
     * Get decrypted data from dataset and write it to a local file.
     */
    downloadToPath(path: string, cipher?: dataset.Cipher): Promise<void>;
    /**
     * Sets the policy of the Dataset service. Pass `null` to unset the policy.
     * @throws if the Identity does not have permission to modify the policy.
     */
    setPolicy<Params>(policy: Policy<Params> | null): Promise<void>;
    /**
     * Sets the new owner of this dataset if the current owner is represented by
     * the connected Identity.
     */
    transferOwnership(newOwner: Identity): Promise<void>;
    /**
     * Marks this Dataset as inactive. This will prevent future access to the data
     * and is equivalent to removing all policies.
     * This does not delete the physical copies of linked data, as it's possible that the
     * (encrypted) data has been cached by another storage cluster or compute node.
     */
    deactivate(): Promise<void>;
    /** Human-readable information about the object's core properties */
    debugString(): Promise<string>;
}
declare type AccessLogEntry = {
    identityAddress: Address;
    timestamp: Date;
    success: boolean;
};
declare type AccessLog = AccessLogEntry[];
