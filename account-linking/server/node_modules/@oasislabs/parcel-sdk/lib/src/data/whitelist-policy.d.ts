import { Address, Set } from 'oasis-std';
import { Config } from '../config';
import { Identity } from '../identity';
import { Policy } from './policy';
export { PolicyCreated as WhitelistPolicyCreated, // DEPRECATED: events will be removed in a future release
AccessChanged as WhitelistPolicyAccessChanged, // DEPRECATED: events will be removed in a future release
Error as WhitelistPolicyError, PolicyDeactivated as WhitelistPolicyDeactivated, } from '../service-clients/whitelist-policy';
export declare type WhitelistPolicyParams = {
    requester: Address;
};
export declare class WhitelistPolicy implements Policy<WhitelistPolicyParams> {
    private client;
    private pubState;
    private config;
    address: Address;
    owner: Address;
    whitelist: Set<Address>;
    active: boolean;
    creationTimestamp: Date;
    deactivationTimestamp: Date;
    private constructor();
    /**
     * Creates a new WhitelistPolicy service.
     * `lifetime` is the number of seconds for which this policy will be active.
     */
    static create(config: Config, owner: Identity, initialWhitelist?: Set<Address>, lifetime?: number): Promise<WhitelistPolicy>;
    static connect(address: Address, identity: Identity, config: Config): Promise<WhitelistPolicy>;
    /**
     * Returns the Unix timestamp at which this policy expires.
     */
    getExpiry(): Promise<number>;
    /**
     * @see `Policy.check`
     * @param `parameters` should be the address you want to validate is on the whitelist.
     */
    check(params: WhitelistPolicyParams, forceLocal?: boolean): Promise<boolean>;
    /** Convenience method for `changeAccess` with only additions. */
    grantAccess(entities: Set<Address>, memo?: string | Uint8Array): Promise<void>;
    /** Convenience method for `changeAccess` with only removals. */
    revokeAccess(entities: Set<Address>, memo?: string | Uint8Array): Promise<void>;
    /**
     * Adds and removes entities from the whitelist.
     * Additional details of the modification can be recorded in the `memo` argument.
     * This can be used to, for example, store a signed message stating the terms
     * under which access was granted or why access was revoked.
     * NOTE: The memo is not accessible via the API right now, but it is recorded
     * on the blockchain.
     */
    changeAccess(toAdd: Set<Address>, toRemove: Set<Address>, memo?: string | Uint8Array): Promise<void>;
    deactivate(): Promise<void>;
    /** Human-readable information about the object's core properties */
    debugString(): Promise<string>;
}
