"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cpolicy = __importStar(require("../service-clients/campaign-policy"));
var campaign_policy_1 = require("../service-clients/campaign-policy");
exports.CampaignJoined = campaign_policy_1.CampaignJoined;
exports.CampaignPolicyError = campaign_policy_1.Error;
exports.CampaignPolicyDeactivated = campaign_policy_1.PolicyDeactivated;
/**
 * A CampaignPolicy whitelists any identity that accepts to the contained `termsOfUse`
 * by calling `CampaignPolicy.join` (assuming that the identity has been invited).
 */
class CampaignPolicy {
    constructor(client, pubState, config, connectedIdentity) {
        this.client = client;
        this.pubState = pubState;
        this.config = config;
        this.connectedIdentity = connectedIdentity;
        this.address = client.address;
        this.owner = pubState.owner;
        this.active = pubState.active;
        if (connectedIdentity.address.equals(this.owner)) {
            this.hasAccess = true;
            this.invited = true;
        }
    }
    /**
     * Creates a new CampaignPolicy service with the specified terms of use and,
     * optionally, an initial set of invited identities (by address) and their user-friendly
     * names/tags, as provided by the camapign policy creator.
     * Specifying invitees restricts participation to just those who have been invited.
     */
    static create(config, owner, termsOfUse, initialInvites) {
        return __awaiter(this, void 0, void 0, function* () {
            return new CampaignPolicy(yield cpolicy.CampaignPolicy.deploy(owner.proxy, {
                owner: owner.address,
                termsOfUse,
                initialInvites,
            }), new cpolicy.PublicState({
                owner: owner.address,
                active: true,
            }), config, owner);
        });
    }
    static connect(address, identity, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield cpolicy.CampaignPolicy.connect(address, identity.proxy);
            const pubState = yield client.getPublicState();
            return new CampaignPolicy(client, pubState, config, identity);
        });
    }
    /**
     * @see `Policy.check`
     * @param `parameters` should be the address you want to validate has agreed to the terms.
     */
    check(params, forceLocal = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceLocal) {
                if (typeof this.hasAccess === 'undefined') {
                    throw new Error('unable to locally determine access');
                }
                return this.hasAccess;
            }
            this.hasAccess = yield this.client.check({ requester: params.requester });
            return this.hasAccess;
        });
    }
    /**
     * Returns the campaign's terms of use, if the caller has been invited.
     */
    getTermsOfUse() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.getTermsOfUse();
        });
    }
    /**
     * Obtains access to the datasets enforcing this policy by agreeing to
     * the `termsOfUse`. An effect of this call is to emit a public event
     * noting that the connected identity has joined (and accepted the terms of)
     * this CampaignPolicy.
     */
    join() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.join();
            this.hasAccess = true;
        });
    }
    /** Returns whether the connected identity has been invited to this campaign */
    checkInvited(forceLocal = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceLocal) {
                if (typeof this.invited === 'undefined') {
                    throw new Error('unable to locally determine invitation status');
                }
                return this.invited;
            }
            this.invited = yield this.client.checkInvited();
            return this.invited;
        });
    }
    /**
     * When called by the owner of the campaign, invites a set of identities to
     * participate. If the campaign was previously open participation, this will
     * restrict new joiners to only those who have been invited.
     * When called with a `Map`, the values are interpreted as user-friendly names,
     * for reference of the inviter.
     */
    invite(invites) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.invite({ invites });
        });
    }
    setOpenParticipation() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.setOpenParticipation();
        });
    }
    /**
     * Returns the invitee address-name map or `undefined` if participation is open.
     */
    getInvites() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.getInvites();
        });
    }
    /**
     * Deactivates this policy. It will respond to no further requests.
     */
    deactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deactivate();
            this.active = false;
            this.hasAccess = false;
            this.invited = false;
        });
    }
    /** Human-readable information about the object's core properties */
    debugString() {
        return __awaiter(this, void 0, void 0, function* () {
            let dbg = `CampaignPolicy${this.active ? '' : ' (DEACTIVATED)'} at ${this.address.hex}
  Owner: ${this.owner.hex}\n`;
            let invites, tos;
            try {
                [invites, tos] = yield Promise.all([this.getInvites(), this.getTermsOfUse()]);
            }
            catch (e) {
                if (e instanceof cpolicy.Error.PermissionDenied) {
                    dbg += `  NOTE: Current identity is not the owner. This tool shows only limited info to non-owners.\n`;
                }
                else {
                    dbg += `  NOTE: Failed to fetch additional info, output below is unreliable. Error: ${e.constructor.name}\n`;
                }
            }
            dbg += '  Invites:';
            if (invites) {
                for (const [address, name] of Array.from(invites.entries())) {
                    dbg += `\n    ${address.hex} - ${name}`;
                }
            }
            else {
                dbg += ' (none)';
            }
            dbg += '\n';
            dbg += `  Terms of use: ${tos !== null && tos !== void 0 ? tos : '(none)'}\n`;
            return dbg.trim();
        });
    }
}
exports.CampaignPolicy = CampaignPolicy;
//# sourceMappingURL=campaign-policy.js.map