"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const readable_stream_1 = require("readable-stream");
const tweetnacl_1 = require("tweetnacl");
const dataset_1 = require("../service-clients/dataset");
const utils_1 = require("../utils");
const oasis_std_1 = require("oasis-std");
const split2_1 = __importDefault(require("split2"));
const AES256CTR_PARAMS = {
    KEY_BYTES: 32,
    IV_BYTES: 16,
    // The part of the IV that is an incremental counter;
    // @see https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams#Properties
    CTR_BYTES: 8,
};
const AES256GCM_PARAMS = {
    KEY_BYTES: 32,
    IV_BYTES: 12,
    // Length of the authentication key.
    AUTH_BYTES: 16,
};
// Brief toString for ciphers.
const hexSnippet = (key) => oasis_std_1.encodeHex(key).slice(0, 6) + '...';
dataset_1.Cipher.Aes256Ctr.prototype.toString = function () {
    return `Aes256Ctr(key=${hexSnippet(this.key)}, iv=${hexSnippet(this.iv)})`;
};
dataset_1.Cipher.Aes256Gcm.prototype.toString = function () {
    return `Aes256Gcm(key=${hexSnippet(this.key)}, iv=${hexSnippet(this.iv)})`;
};
dataset_1.Cipher.Plaintext.prototype.toString = function () {
    return `Plaintext`;
};
function createAes256CtrCipher() {
    return new dataset_1.Cipher.Aes256Ctr({
        key: tweetnacl_1.randomBytes(AES256CTR_PARAMS.KEY_BYTES),
        iv: buffer_1.Buffer.concat([
            buffer_1.Buffer.from(tweetnacl_1.randomBytes(AES256CTR_PARAMS.IV_BYTES - AES256CTR_PARAMS.CTR_BYTES)),
            buffer_1.Buffer.alloc(AES256CTR_PARAMS.CTR_BYTES),
        ]),
    });
}
exports.createAes256CtrCipher = createAes256CtrCipher;
function createAes256GcmCipher() {
    return new dataset_1.Cipher.Aes256Gcm({
        key: tweetnacl_1.randomBytes(AES256GCM_PARAMS.KEY_BYTES),
        iv: tweetnacl_1.randomBytes(AES256GCM_PARAMS.IV_BYTES),
    });
}
exports.createAes256GcmCipher = createAes256GcmCipher;
function createAesVcfCipher() {
    return new dataset_1.Cipher.AesVcf({
        key: tweetnacl_1.randomBytes(AES256GCM_PARAMS.KEY_BYTES),
    });
}
exports.createAesVcfCipher = createAesVcfCipher;
function createCipherByName(cipherName) {
    if (cipherName === 'aes-256-ctr')
        return createAes256CtrCipher();
    if (cipherName === 'aes-256-gcm')
        return createAes256GcmCipher();
    if (cipherName === 'aes-vcf')
        return createAesVcfCipher();
    if (cipherName === 'plaintext')
        return new dataset_1.Cipher.Plaintext();
    utils_1.unreachable(cipherName, `unsupported cipher name: ${cipherName}`);
}
exports.createCipherByName = createCipherByName;
exports.createDefaultCipher = createAes256GcmCipher;
function toUint8Array(input) {
    if (utils_1.isUint8Array(input)) {
        return Promise.resolve(input);
    }
    else {
        return utils_1.collectByteStream(input);
    }
}
/**
 * Encrypts some data using a randomly generated key (and randomly generated nonce).
 * This method assumes that the content-addressable storage correctly handles authentication
 * (e.g., through a Merkle structure).
 * It also assumes that the key returned in the `CipherParams` is not reused.
 * @returns the encryption result including the cipher params and the ciphertext.
 */
function encrypt(plaintext, cipher) {
    if (cipher instanceof dataset_1.Cipher.AesVcf) {
        const ciphertext = encryptAesVcf(utils_1.toReadable(plaintext), cipher);
        return { cipher, ciphertext };
    }
    const ciphertext = utils_1.isNode
        ? encryptNode(utils_1.toReadable(plaintext), cipher)
        : utils_1.toReadable(encryptBrowser(toUint8Array(plaintext), cipher));
    return {
        cipher,
        ciphertext,
    };
}
exports.encrypt = encrypt;
function encryptNode(plaintext, cipher) {
    const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires
    if (cipher instanceof dataset_1.Cipher.Plaintext) {
        return plaintext;
    }
    else if (cipher instanceof dataset_1.Cipher.Aes256Ctr) {
        return plaintext.pipe(crypto.createCipheriv('aes-256-ctr', cipher.key, cipher.iv));
    }
    else if (cipher instanceof dataset_1.Cipher.Aes256Gcm) {
        // The Rust and browser implementations of AES-GCM encryption return concat(ciphertext, authenticationTag).
        // The Nodejs crypto library does not; it provides the tag separately. We manually construct a stream that
        // is a concatenates the two. We cannot use pre-existing stream concatenation libraries, because the
        // contents of the second stream (=authTag) are only known after the first stream (=ciphertext) has been
        // depleted.
        const cipherTransform = crypto.createCipheriv('aes-256-gcm', cipher.key, cipher.iv); // a read+write stream
        // Pipe plaintext through AES. When AES ends, also output the authTag.
        return plaintext.pipe(cipherTransform).pipe(new readable_stream_1.PassThrough({
            flush(cb) {
                cb(undefined, cipherTransform.getAuthTag());
            },
        }));
    }
    utils_1.unreachable(cipher, 'unsupported cipher');
}
function encryptBrowser(plaintext, cipher) {
    return __awaiter(this, void 0, void 0, function* () {
        if (cipher instanceof dataset_1.Cipher.Plaintext) {
            return plaintext;
        }
        let encryptionParams;
        let name;
        if (cipher instanceof dataset_1.Cipher.Aes256Ctr) {
            name = 'AES-CTR';
            encryptionParams = {
                name,
                length: 128,
                counter: cipher.iv,
            };
        }
        else if (cipher instanceof dataset_1.Cipher.Aes256Gcm) {
            name = 'AES-GCM';
            encryptionParams = {
                name,
                iv: cipher.iv,
                tagLength: AES256GCM_PARAMS.AUTH_BYTES * 8,
            };
        }
        else {
            utils_1.unreachable(cipher, 'unsupported cipher');
        }
        const [key, plaintextBuf] = yield Promise.all([importKeyBrowser(name, cipher.key), plaintext]);
        return crypto.subtle.encrypt(encryptionParams, key, plaintextBuf);
    });
}
/**
 * Decrypts previously encrypted data.
 * @returns the decrypted data.
 */
function decrypt(cipher, ciphertext) {
    if (cipher instanceof dataset_1.Cipher.AesVcf) {
        return utils_1.toReadable(decryptAesVcf(utils_1.toReadable(ciphertext), cipher));
    }
    return utils_1.isNode
        ? decryptNode(cipher, utils_1.toReadable(ciphertext))
        : utils_1.toReadable(decryptBrowser(cipher, toUint8Array(ciphertext)));
}
exports.decrypt = decrypt;
function decryptNode(cipher, ciphertext) {
    const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires
    if (cipher instanceof dataset_1.Cipher.Plaintext) {
        return ciphertext;
    }
    else if (cipher instanceof dataset_1.Cipher.Aes256Ctr) {
        return ciphertext.pipe(crypto.createDecipheriv('aes-256-ctr', cipher.key, cipher.iv));
    }
    else if (cipher instanceof dataset_1.Cipher.Aes256Gcm) {
        // Input `ciphertext` is really concat(ciphertext, authTag), and the crypto library wants
        // us to feed it the authTag separately. Rename the variable here for readability.
        const textAndTag = ciphertext;
        const decipherTransform = crypto.createDecipheriv('aes-256-gcm', cipher.key, cipher.iv);
        let buf = buffer_1.Buffer.from([]);
        return textAndTag
            .pipe(
        // This Transform is mostly a PassThrough, except that always withholds the most recent
        // AES256GCM_PARAMS.AUTH_BYTES=16 bytes in a small buffer `buf`. At the end, it sets the
        // authTag for `decipherTransform` with those remaining 16 bytes.
        new readable_stream_1.Transform({
            transform(chunk, _encoding, cb) {
                // Flush `buf`; put last AES256GCM_PARAMS.AUTH_BYTES bytes in `buf`.
                buf = buffer_1.Buffer.concat([buf, chunk]);
                if (buf.byteLength > AES256GCM_PARAMS.AUTH_BYTES) {
                    const notTag = buf.slice(0, buf.byteLength - AES256GCM_PARAMS.AUTH_BYTES);
                    buf = buf.slice(buf.byteLength - AES256GCM_PARAMS.AUTH_BYTES);
                    cb(undefined, notTag);
                }
                else {
                    cb();
                }
            },
            flush(cb) {
                // Input ran out, so `buf` contains the last AES256GCM_PARAMS.AUTH_BYTES of the entire
                // input, i.e. the authTag.
                if (buf.byteLength !== AES256GCM_PARAMS.AUTH_BYTES) {
                    cb(new Error(`Invalid input: The entirety of ciphertext is only ${buf.byteLength} != ${AES256GCM_PARAMS.AUTH_BYTES} bytes long. At least that many bytes are required for the auth tag.`));
                }
                // We can set the auth tag as long as decipherTransform's input stream is alive.
                try {
                    decipherTransform.setAuthTag(buf);
                    cb();
                }
                catch (e) {
                    cb(e);
                }
            },
        }))
            .on('error', decipherTransform.destroy.bind(decipherTransform))
            .pipe(decipherTransform);
    }
    utils_1.unreachable(cipher, 'unsupported cipher');
}
function decryptBrowser(cipher, ciphertext) {
    return __awaiter(this, void 0, void 0, function* () {
        if (cipher instanceof dataset_1.Cipher.Plaintext) {
            return ciphertext;
        }
        let decryptionParams;
        let name;
        if (cipher instanceof dataset_1.Cipher.Aes256Ctr) {
            name = 'AES-CTR';
            decryptionParams = {
                name,
                counter: cipher.iv,
                length: 128,
            };
        }
        else if (cipher instanceof dataset_1.Cipher.Aes256Gcm) {
            name = 'AES-GCM';
            decryptionParams = {
                name,
                iv: cipher.iv,
                tagLength: AES256GCM_PARAMS.AUTH_BYTES * 8,
            };
        }
        else {
            utils_1.unreachable(cipher, 'unsupported cipher');
        }
        const [key, ciphertextBuf] = yield Promise.all([
            importKeyBrowser(name, cipher.key),
            ciphertext,
        ]);
        return crypto.subtle.decrypt(decryptionParams, key, ciphertextBuf);
    });
}
function importKeyBrowser(algoName, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyBuf = key.buffer.slice(key.byteOffset, key.byteOffset + key.byteLength);
        if (key.length !== AES256CTR_PARAMS.KEY_BYTES) {
            throw new Error('unsupported key');
        }
        return crypto.subtle.importKey('raw', keyBuf, algoName, false /* extractable */, ['encrypt', 'decrypt'] /* keyUsages */);
    });
}
function encryptAesVcf(plaintext, cipher) {
    return processVcf(plaintext, 'String', (gp) => {
        // Create cipher for the GP value. Retain the key, create a new IV.
        const gpCipher = new dataset_1.Cipher.Aes256Gcm({
            key: cipher.key,
            iv: tweetnacl_1.randomBytes(AES256GCM_PARAMS.IV_BYTES),
        });
        // Concatenate GP IV and GP ciphertext
        const ivAndCiphertext = new readable_stream_1.PassThrough();
        const gpCiphertext = encrypt(buffer_1.Buffer.from(gp), gpCipher).ciphertext;
        ivAndCiphertext.push(gpCipher.iv);
        gpCiphertext.pipe(ivAndCiphertext);
        // Encode with base64. Input `gp` is <10kB, so we're OK to collect the stream.
        const base64 = new readable_stream_1.PassThrough();
        utils_1.collectByteStream(ivAndCiphertext)
            .then((chunk) => base64.end(chunk.toString('base64')))
            .catch((err) => base64.destroy(err));
        return base64;
    });
}
function decryptAesVcf(ciphertext, cipher) {
    return processVcf(ciphertext, 'Float', (gp) => {
        if (gp === '.')
            return utils_1.toReadable(buffer_1.Buffer.from(gp)); // denotes lack of measurement; did not have to be encrypted
        const buf = buffer_1.Buffer.from(gp, 'base64');
        // Create cipher for the GP value. Keep the global key, pull the IV from the GP ciphertext.
        const gpCipher = new dataset_1.Cipher.Aes256Gcm({
            key: cipher.key,
            iv: buf.slice(0, AES256GCM_PARAMS.IV_BYTES),
        });
        return decrypt(gpCipher, buf.slice(AES256GCM_PARAMS.IV_BYTES));
    });
}
class VcfGpTransform extends readable_stream_1.Transform {
    constructor(gpType, gpMapper) {
        super();
        this.gpType = gpType;
        this.gpMapper = gpMapper;
        this.nMappedFields = 0;
    }
    _transform(lineBuf, _encoding, lineDone) {
        // Number of "fixed columns". This is given by the spec: https://samtools.github.io/hts-specs/VCFv4.1.pdf.
        // These columns come first and do not contain GP data. All following columns do.
        // The last of these fixed columns contains the format info for subcolumns of non-fixed columns.
        const nFixedColumns = 9;
        const formatCol = 8;
        const line = lineBuf.toString();
        const processed = []; // output chunks
        if (line.startsWith('##FORMAT=<ID=GP')) {
            // Header line that dictates the type of GP; change type as instructed.
            processed.push(line.replace(/Type *= *[A-Za-z]+/, `Type=${this.gpType}`));
        }
        else if (line.startsWith('#')) {
            // Other header line; keep as-is.
            processed.push(line);
        }
        else if (!line.trim()) {
            // Whitespace line; keep as-is.
            processed.push(line);
        }
        else {
            const trimmedLine = line.trimRight();
            const gpCol = trimmedLine.split('\t')[formatCol].split(':').indexOf('GP');
            if (gpCol === -1) {
                // No GP subcolumn in this line; nothing to process.
                processed.push(line);
            }
            else {
                const columns = trimmedLine.split('\t');
                // The first several columns do not contain GP data; keep as-is.
                processed.push(columns.slice(0, nFixedColumns).join('\t'));
                // For other columns, split into subcolumns on ":", and process
                // the applicable subcolumns.
                for (let col = nFixedColumns; col < columns.length; col++) {
                    processed.push('\t');
                    const subcolumns = columns[col].split(':');
                    for (let subcol = 0; subcol < subcolumns.length; subcol++) {
                        if (subcol > 0)
                            processed.push(':');
                        if (subcol === gpCol) {
                            this.nMappedFields++;
                            processed.push(this.gpMapper(subcolumns[gpCol]));
                        }
                        else {
                            processed.push(subcolumns[subcol]);
                        }
                    }
                }
                processed.push(line.substring(trimmedLine.length));
            }
        }
        // Merge all output chunks. We cannot directly use `this.push()` above because
        // `gpMapper` is async. First, represent each chunk as a Future ...
        const promises = processed.map((chunk) => typeof chunk === 'string'
            ? Promise.resolve(buffer_1.Buffer.from(chunk))
            : utils_1.collectByteStream(chunk));
        // ... then write their concatenation to output.
        Promise.all(promises)
            .then((chunks) => lineDone(undefined, buffer_1.Buffer.concat(chunks)))
            .catch((err) => lineDone(err, undefined));
    }
    _flush(done) {
        if (this.nMappedFields === 0) {
            console.log('WARNING: VCF encryption made no changes to the file. Perhaps the file was not a valid VCF, or did not contain a GP column?');
        }
        done();
    }
}
function processVcf(vcfContents, gpType, gpMapper) {
    return vcfContents.pipe(split2_1.default(/^/m)).pipe(new VcfGpTransform(gpType, gpMapper));
}
//# sourceMappingURL=crypto.js.map