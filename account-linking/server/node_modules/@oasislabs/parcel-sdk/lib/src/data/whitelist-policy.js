"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const oasis_std_1 = require("oasis-std");
const buffer_1 = require("buffer");
const wpolicy = __importStar(require("../service-clients/whitelist-policy"));
var whitelist_policy_1 = require("../service-clients/whitelist-policy");
exports.WhitelistPolicyCreated = whitelist_policy_1.PolicyCreated;
exports.WhitelistPolicyAccessChanged = whitelist_policy_1.AccessChanged;
exports.WhitelistPolicyError = whitelist_policy_1.Error;
exports.WhitelistPolicyDeactivated = whitelist_policy_1.PolicyDeactivated;
const utils_1 = require("../utils");
class WhitelistPolicy {
    constructor(client, pubState, config) {
        this.client = client;
        this.pubState = pubState;
        this.config = config;
        this.creationTimestamp = new Date(0);
        this.deactivationTimestamp = new Date(0);
        this.address = client.address;
        this.owner = pubState.owner;
        this.whitelist = pubState.whitelist;
        this.active = pubState.active;
    }
    /**
     * Creates a new WhitelistPolicy service.
     * `lifetime` is the number of seconds for which this policy will be active.
     */
    static create(config, owner, initialWhitelist = new oasis_std_1.Set(), lifetime) {
        return __awaiter(this, void 0, void 0, function* () {
            const deployOptions = {};
            if (typeof lifetime !== 'undefined') {
                deployOptions.expiry = Math.floor(Date.now() /* millis */ / 1000) + lifetime;
            }
            const deployedWhitelist = new WhitelistPolicy(yield wpolicy.WhitelistPolicy.deploy(owner.proxy, {
                owner: owner.address,
                initialWhitelist,
            }, deployOptions), new wpolicy.PublicState({
                owner: owner.address,
                whitelist: initialWhitelist,
                active: true,
            }), config);
            // Assign out-of-band attributes. On `deploy` this is set to the current
            // timestamp as an estimate of the true creation timestamp, since the
            // creation event may not have been propagated to the indexer yet.
            deployedWhitelist.creationTimestamp = new Date();
            return deployedWhitelist;
        });
    }
    static connect(address, identity, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield wpolicy.WhitelistPolicy.connect(address, identity.proxy);
            let whitelistPolicy;
            try {
                const res = yield utils_1.queryIndex('policy/getPolicyPublicState', address, config.indexerUrl, config.oasisGateway, config.tokenProvider, {
                    policy: address.hex,
                }, config.log);
                whitelistPolicy = new WhitelistPolicy(client, new wpolicy.PublicState({
                    owner: new oasis_std_1.Address(res.owner),
                    whitelist: new oasis_std_1.Set(res.whitelist.map((identityAddress) => new oasis_std_1.Address(identityAddress))),
                    active: res.active,
                }), config);
                // Assign out-of-band attributes.
                whitelistPolicy.creationTimestamp = new Date(res.creationTimestamp * 1000);
                whitelistPolicy.deactivationTimestamp = new Date(res.deactivationTimestamp * 1000);
            }
            catch (err) {
                whitelistPolicy = new WhitelistPolicy(client, yield client.getPublicState(), config);
                if (err instanceof utils_1.UnindexedObjectError) {
                    // The chain does not conveniently expose the creation timestamp; it can only
                    // be inferred by listening to (or replaying) the PolicyCreated event. The best we can do here
                    // is guess the approximate time. Since the indexer doesn't know the Dataset but the chain does,
                    // it is most likely that the policy was created just a few seconds ago.
                    whitelistPolicy.creationTimestamp = new Date();
                }
            }
            return whitelistPolicy;
        });
    }
    /**
     * Returns the Unix timestamp at which this policy expires.
     */
    getExpiry() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.config.oasisGateway.getExpiry(this.address);
        });
    }
    /**
     * @see `Policy.check`
     * @param `parameters` should be the address you want to validate is on the whitelist.
     */
    check(params, forceLocal = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceLocal) {
                return this.whitelist.has(params.requester);
            }
            return this.client.check({ requester: params.requester });
        });
    }
    /** Convenience method for `changeAccess` with only additions. */
    grantAccess(entities, memo) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.changeAccess(entities, new oasis_std_1.Set(), memo);
        });
    }
    /** Convenience method for `changeAccess` with only removals. */
    revokeAccess(entities, memo) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.changeAccess(new oasis_std_1.Set(), entities, memo);
        });
    }
    /**
     * Adds and removes entities from the whitelist.
     * Additional details of the modification can be recorded in the `memo` argument.
     * This can be used to, for example, store a signed message stating the terms
     * under which access was granted or why access was revoked.
     * NOTE: The memo is not accessible via the API right now, but it is recorded
     * on the blockchain.
     */
    changeAccess(toAdd, toRemove, memo = new Uint8Array()) {
        return __awaiter(this, void 0, void 0, function* () {
            const memoBytes = typeof memo === 'string' ? buffer_1.Buffer.from(memo) : memo;
            yield this.client.changeAccess({ toAdd, toRemove, memo: memoBytes });
            for (const entity of toAdd) {
                this.whitelist.add(entity);
            }
            for (const entity of toRemove) {
                this.whitelist.delete(entity);
            }
        });
    }
    deactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.deactivate();
            this.active = false;
            this.deactivationTimestamp = new Date();
        });
    }
    /** Human-readable information about the object's core properties */
    debugString() {
        return __awaiter(this, void 0, void 0, function* () {
            let dbg = `WhitelistPolicy${this.active ? '' : ' (DEACTIVATED)'} at ${this.address.hex}
  Owner: ${this.owner.hex}
  Whitelisted addresses:`;
            for (const addr of Array.from(this.whitelist.values())) {
                dbg += `\n    ${addr.hex}`;
            }
            if (this.whitelist.size === 0)
                dbg += ' (none)';
            return dbg.trim();
        });
    }
}
exports.WhitelistPolicy = WhitelistPolicy;
//# sourceMappingURL=whitelist-policy.js.map