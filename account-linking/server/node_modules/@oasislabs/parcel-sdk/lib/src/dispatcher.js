"use strict";
/* eslint-disable @typescript-eslint/no-namespace */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const oasis_std_1 = require("oasis-std");
const buffer_1 = require("buffer");
const dispatcher = __importStar(require("./service-clients/dispatcher"));
const config_1 = require("./config");
const utils_1 = require("./utils");
var dispatcher_1 = require("./service-clients/dispatcher");
exports.DatasetRequestError = dispatcher_1.DatasetRequestError;
exports.DispatcherError = dispatcher_1.Error;
exports.JobCompleted = dispatcher_1.JobCompleted;
exports.JobCompletionStatus = dispatcher_1.JobCompletionStatus;
exports.Secrets = dispatcher_1.Secrets;
dispatcher.Error.PermissionDenied.prototype.toString = function () {
    return 'permission denied';
};
dispatcher.Error.AlreadyRegistered.prototype.toString = function () {
    return 'worker has already been registered';
};
dispatcher.Error.NotEnoughWorkers.prototype.toString = function () {
    return 'not enough available workers';
};
dispatcher.Error.QuotaExceeded.prototype.toString = function () {
    return 'quota exceeded';
};
dispatcher.Error.NoSuchJob.prototype.toString = function () {
    return 'job doesn\'t exist';
};
dispatcher.Error.Deactivated.prototype.toString = function () {
    return 'dispatcher has been deactivated';
};
dispatcher.Error.DatasetRequestsFailed.prototype.toString = function () {
    const msgs = ['failed to fetch datasets:'];
    for (const [addr, dsErr] of this[0]) {
        msgs.push(`    ${addr.hex}: ${dsErr}`);
    }
    return msgs.join('\n');
};
dispatcher.Error.InvalidJobCompletionStatus.prototype.toString = function () {
    return 'invalid job completion status was passed as an argument to a function';
};
dispatcher.DatasetRequestError.Unreachable.prototype.toString = function () {
    return 'unreachable';
};
dispatcher.DatasetRequestError.DatasetError.prototype.toString = function () {
    return `dataset error: ${this[0].constructor.name}`;
};
// Converts a status enum value (as returned by the indexer) into the native
// representation.
function jobCompletionStatusFromIdx(i) {
    const values = dispatcher.JobCompletionStatus.VARIANTS;
    if (i < 0 || i >= values.length) {
        throw new Error(`Invalid JobCompletionStatus index: ${i}`);
    }
    return new values[i]();
}
class Dispatcher {
    constructor(client, config) {
        this.client = client;
        this.config = config;
        // Forward the remaining RPCs straight to the on-chain service.
        this.getPendingJobIds = this.client.getPendingJobIds.bind(this.client);
        this.getQuota = this.client.getQuota.bind(this.client);
        this.increaseQuota = this.client.increaseQuota.bind(this.client);
        this.getQuotaOf = this.client.getQuotaOf.bind(this.client);
        this.deactivate = this.client.deactivate.bind(this.client);
        this.address = client.address;
    }
    /** Connect to an existing dispatcher at `address` using the authority of `identity`. **/
    static connect(address, identity, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const inner = yield dispatcher.Dispatcher.connect(address, identity.proxy);
            yield inner.getPendingJobsById({ jobIds: [] }); // no-op call to test service availability
            return new Dispatcher(inner, config);
        });
    }
    /** Create a new Dispatcher, owned by `executor`. **/
    static deploy(executor, config) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Dispatcher(yield dispatcher.Dispatcher.deploy(executor.proxy, { executor: executor.address }), config);
        });
    }
    /**
     * Fetches additional info about job request `job` from the dispatcher.
     *
     * Implementation note:
     * To keep the dispatcher ABI stable, most info about the job is JSON-serialized inside the `userSecret` field at
     * the Rust level. This unfortunately means somewhat more boilerplate here to carefully parse that JSON.
     **/
    augmentJobRequest(job) {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve secrets
            let secrets;
            try {
                secrets = yield this.client.retrieveSecrets({ jobId: job.id });
            }
            catch (err) {
                throw new Error(`Failed to fetch job secrets from dispatcher: ${err}`);
            }
            // Parse secrets into JobRequestFull fields
            const datasetCiphers = new Map(secrets.datasetCiphers.map((kv) => [kv[0].hex, kv[1]]));
            let userSecret; // Contents of `secret.userSecret`, interpreted as JSON
            const userSecretStr = buffer_1.Buffer.from(secrets.userSecret[0]).toString();
            try {
                userSecret = JSON.parse(userSecretStr);
            }
            catch (err) {
                throw new Error(`Parcel internal error: Failed to interpret \`userSecret\` as JSON: ${err}. \`userSecret\` was: ${userSecretStr}`);
            }
            if (!Array.isArray(userSecret.cmd)) {
                throw new Error(`Invalid cmd: ${JSON.stringify(userSecret.cmd)}; must be an array`);
            }
            const cmd = [...userSecret.cmd]; // get rid of any extra properties
            cmd.map((el) => {
                if (typeof el !== 'string')
                    throw new Error(`Invalid cmd: ${JSON.stringify(cmd)}; not all elements are strings`);
            });
            const dockerImage = userSecret.dockerImage;
            if (typeof dockerImage !== 'string' && typeof dockerImage !== 'undefined') {
                throw new Error(`Invalid value for dockerImage: ${dockerImage}`);
            }
            const env = {};
            for (const [k, v] of Object.entries(userSecret.env || {})) {
                if (typeof k !== 'string' || typeof v !== 'string') {
                    throw new Error(`Maformed env, keys or values are not strings. \`userSecret\` was: ${userSecretStr}`);
                }
                env[k] = v;
            }
            const inputDatasets = [];
            for (const d of userSecret.inputDatasets || []) {
                if (typeof d.mountPath !== 'string') {
                    throw new Error(`Malformed job request: An input dataset does not specify a mountpath. \`userSecret\` was: ${userSecretStr}`);
                }
                let address;
                try {
                    address = new oasis_std_1.Address(d.address);
                }
                catch (err) {
                    throw new Error(`Maformed job request: An input dataset does not specify a valid address: ${err}. \`userSecret\` was: ${userSecretStr}`);
                }
                inputDatasets.push({ mountPath: d.mountPath, address });
            }
            const outputDatasets = [];
            for (const d of userSecret.outputDatasets || []) {
                if (typeof d.mountPath !== 'string') {
                    throw new Error(`Malformed job request: An output dataset does not specify a mountpath. \`userSecret\` was: ${userSecretStr}`);
                }
                let owner;
                try {
                    owner = new oasis_std_1.Address(d.owner);
                }
                catch (err) {
                    throw new Error(`Maformed job request: An output dataset does not specify a valid owner address: ${err}. \`userSecret\` was: ${userSecretStr}`);
                }
                let policy = undefined;
                if (d.policy) {
                    try {
                        policy = new oasis_std_1.Address(d.policy);
                    }
                    catch (err) {
                        throw new Error(`Maformed job request: An output dataset does not specify a valid policy address: ${err}. \`userSecret\` was: ${userSecretStr}`);
                    }
                }
                outputDatasets.push({ mountPath: d.mountPath, owner, policy });
            }
            if (typeof secrets.submitterToken !== 'string') {
                throw new Error('Maformed job request: no submitterToken provided');
            }
            let submitterConfig;
            try {
                submitterConfig = new config_1.Config(Object.assign({}, this.config.params, {
                    apiTokenSigner: undefined,
                    apiAccessToken: secrets.submitterToken,
                    storageBackends: JSON.parse(secrets.storageConfig),
                }));
            }
            catch (err) {
                throw new Error(`Maformed job request: Failed to construct a Config due to invalid submitterToken "${secrets.submitterToken}" or storageConfig "${secrets.storageConfig}": ${err}`);
            }
            return {
                id: job.id,
                name: job.name,
                cmd,
                dockerImage,
                env,
                inputDatasets,
                outputDatasets,
                datasetCiphers,
                submitterConfig,
            };
        });
    }
    /** Returns information (notably, the completion status and output datasets)
     * for a job that was previously submitted to this Dispatcher. Throws if the
     * job ID does not exist. **/
    getJobInfo(jobId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield utils_1.queryIndex('dispatcher/getJobInfo', this.address, this.config.indexerUrl, this.config.oasisGateway, this.config.tokenProvider, {
                dispatcher: this.address.hex,
                jobId: buffer_1.Buffer.from(jobId).toString('hex'),
            }, this.config.log);
            // Parse indexer response.
            this.config.log.trace({ rawIndexerResponse: res }, `Retrieved job info for job ${buffer_1.Buffer.from(jobId).toString('hex')}`);
            let parsedOutputDatasets;
            try {
                parsedOutputDatasets = res.outputs.map(({ name, address }) => ({
                    mountPath: name,
                    address: new oasis_std_1.Address(address),
                }));
            }
            catch (err) {
                throw new Error(`Failed to parse output datasets in indexer JobInfo response: ${err}`);
            }
            let parsedStatus;
            try {
                parsedStatus = jobCompletionStatusFromIdx(res.status);
            }
            catch (err) {
                throw new Error(`Failed to parse job status from indexer JobInfo response: ${err}`);
            }
            this.config.log.trace({ parsedOutputDatasets }, 'output datasets parsed');
            return {
                status: parsedStatus,
                outputs: parsedOutputDatasets,
                info: res.info,
            };
        });
    }
    /**
     * Same as `getJobInfo()`, but the return Promise does not resolve until the
     * job has finished executing. While waiting for the job to complete, this
     * function will check its status every `pollIntervalSeconds`, for a maximum
     * duration of `timeoutSeconds`.
     **/
    getCompletedJobInfo(jobId, pollIntervalSeconds = 5, timeoutSeconds = 3600) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const jobPolling = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    let jobInfo;
                    try {
                        jobInfo = yield this.getJobInfo(jobId);
                    }
                    catch (err) {
                        reject(err);
                        return;
                    }
                    if (!(jobInfo.status instanceof dispatcher.JobCompletionStatus.Pending)) {
                        this.config.log.debug({
                            jobId: oasis_std_1.encodeHex(jobId),
                            jobInfo: Object.assign(Object.assign({}, jobInfo), { status: jobInfo.status.constructor.name }),
                        }, 'Job completed');
                        clearInterval(jobPolling);
                        if (timeout)
                            clearTimeout(timeout);
                        resolve(jobInfo);
                    }
                    else {
                        this.config.log.trace({ jobId: oasis_std_1.encodeHex(jobId) }, 'Job still pending');
                    }
                }), pollIntervalSeconds * 1000);
                const timeout = setTimeout(() => {
                    const errMsg = `Timed out waiting for compute job to complete within ${timeoutSeconds} seconds. The job might still be running, or there might be an infrastructure problem.`;
                    this.config.log.warn({ jobId }, errMsg);
                    clearInterval(jobPolling);
                    reject(new Error(errMsg));
                }, timeoutSeconds * 1000);
            });
        });
    }
    /** Human-readable information about the object's core properties */
    debugString() {
        return __awaiter(this, void 0, void 0, function* () {
            let dbg = `Dispatcher at ${this.address.hex}
  Pending jobs:`;
            let jobs = undefined;
            try {
                jobs = yield this.getPendingJobs();
            }
            catch (e) {
                dbg += ` (Cannot fetch jobs info. Error: ${e.constructor.name})`;
            }
            if (jobs) {
                for (const job of jobs) {
                    dbg += `
    ${buffer_1.Buffer.from(job.id).toString('hex')}
      Name:     ${job.name}
      Datasets: ${job.requestedDatasets.map((addr) => addr.hex).join(' ')}`;
                }
                if (jobs.length === 0) {
                    dbg += ' (none)';
                }
            }
            return dbg.trim();
        });
    }
    submitJob({ job }, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.submitJob({
                job: new dispatcher.JobRequest({
                    name: job.name,
                    programRef: '',
                    expectedMrenclave: new Uint8Array(32),
                    requestedDatasets: (job.inputDatasets || []).map((d) => d.address),
                    storageConfig: JSON.stringify(this.config.storageConfig),
                    // The entire `job` gets tucked inside `userSecrets`; `name` is an
                    // exception and is also sent as a public field.
                    userSecret: new dispatcher.Bytes(buffer_1.Buffer.from(JSON.stringify({
                        name: job.name,
                        cmd: job.cmd,
                        dockerImage: job.dockerImage,
                        env: job.env,
                        inputDatasets: (_a = job.inputDatasets) === null || _a === void 0 ? void 0 : _a.map((d) => ({
                            mountPath: d.mountPath,
                            address: d.address.hex,
                        })),
                        outputDatasets: (_b = job.outputDatasets) === null || _b === void 0 ? void 0 : _b.map((d) => {
                            var _a;
                            return ({
                                mountPath: d.mountPath,
                                owner: d.owner.address.hex,
                                policy: (_a = d.policy) === null || _a === void 0 ? void 0 : _a.address.hex,
                            });
                        }),
                    }))),
                    userData: new dispatcher.Bytes(new Uint8Array()),
                    submitterToken: yield this.config.tokenProvider.getToken(),
                }),
            }, options);
        });
    }
    /**
     * Returns all pending jobs. If `jobIds` is set, returns only those with matching ids.
     * This method is ideally called with `jobIds` after appropriately subsetting the ids
     * returned by `getPendingJobIds` to avoid going over the gas limit.
     */
    getPendingJobs(kwargs) {
        return __awaiter(this, void 0, void 0, function* () {
            let pendingJobs;
            const jobIds = kwargs === null || kwargs === void 0 ? void 0 : kwargs.jobIds;
            if (typeof jobIds !== 'undefined') {
                if (!jobIds)
                    return [];
                pendingJobs = yield this.client.getPendingJobsById({ jobIds });
            }
            else {
                pendingJobs = yield this.client.getPendingJobs();
            }
            return pendingJobs;
        });
    }
    /**
     * Marks job `jobId` as complete, with status `status` and having produced
     * `outputs`. `info` is additional human-readable information about the
     * `status`, intended especially for the case of errors.
     *
     * This method is intended to be called only by the offchain worker. Unless
     * you are developing the Parcel stack itself, you probably od not need this
     * method.
     **/
    completeJob({ jobId, status, outputs, info, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.completeJob({
                jobId,
                status,
                outputs: outputs.map((d) => new dispatcher.OutputDataset({ name: d.mountPath, address: d.address })),
                info,
            });
        });
    }
}
exports.Dispatcher = Dispatcher;
//# sourceMappingURL=dispatcher.js.map