import * as oasis from 'oasis-std';
import * as dataset from './dataset';
export declare class JobRequest implements oasis.AbiEncodable {
    name: string;
    programRef: string;
    expectedMrenclave: Uint8Array;
    requestedDatasets: oasis.Address[];
    userData: Bytes;
    userSecret: Bytes;
    storageConfig: string;
    submitterToken: string;
    constructor(fields: {
        name: string;
        programRef: string;
        expectedMrenclave: Uint8Array;
        requestedDatasets: oasis.Address[];
        userData: Bytes;
        userSecret: Bytes;
        storageConfig: string;
        submitterToken: string;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): JobRequest;
}
export declare class Secrets implements oasis.AbiEncodable {
    datasetCiphers: [oasis.Address, dataset.Cipher][];
    userSecret: Bytes;
    storageConfig: string;
    submitterToken: string;
    constructor(fields: {
        datasetCiphers: [oasis.Address, dataset.Cipher][];
        userSecret: Bytes;
        storageConfig: string;
        submitterToken: string;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): Secrets;
}
export declare class JobSubmitted implements oasis.AbiEncodable {
    id: Uint8Array;
    name: string;
    programRef: string;
    expectedMrenclave: Uint8Array;
    requestedDatasets: oasis.Address[];
    userData: Bytes;
    constructor(fields: {
        id: Uint8Array;
        name: string;
        programRef: string;
        expectedMrenclave: Uint8Array;
        requestedDatasets: oasis.Address[];
        userData: Bytes;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): JobSubmitted;
    static subscribe(gateway: oasis.Gateway, address: oasis.Address | null, topics?: {
        id?: Uint8Array;
        name?: string;
        programRef?: string;
        expectedMrenclave?: Uint8Array;
        requestedDatasets?: oasis.Address[];
        userData?: Bytes;
    }): Promise<oasis.Subscription<JobSubmitted>>;
}
export declare class JobCompleted implements oasis.AbiEncodable {
    id: Uint8Array;
    status: JobCompletionStatus;
    outputs: OutputDataset[];
    info: string;
    constructor(fields: {
        id: Uint8Array;
        status: JobCompletionStatus;
        outputs: OutputDataset[];
        info: string;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): JobCompleted;
    static subscribe(gateway: oasis.Gateway, address: oasis.Address | null, topics?: {
        id?: Uint8Array;
        status?: JobCompletionStatus;
        outputs?: OutputDataset[];
        info?: string;
    }): Promise<oasis.Subscription<JobCompleted>>;
}
export declare class OutputDataset implements oasis.AbiEncodable {
    name: string;
    address: oasis.Address;
    constructor(fields: {
        name: string;
        address: oasis.Address;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): OutputDataset;
}
export declare module JobCompletionStatus {
    class Success implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Success;
    }
    class JobSetupError implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): JobSetupError;
    }
    class RuntimeError implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): RuntimeError;
    }
    class Pending implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Pending;
    }
    class Cancelled implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Cancelled;
    }
    function abiDecode(decoder: oasis.Decoder): JobCompletionStatus;
    const VARIANTS: Function[];
    function isVariant(obj: any): obj is JobCompletionStatus;
}
export declare type JobCompletionStatus = JobCompletionStatus.Success | JobCompletionStatus.JobSetupError | JobCompletionStatus.RuntimeError | JobCompletionStatus.Pending | JobCompletionStatus.Cancelled;
export declare module Error {
    class PermissionDenied implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): PermissionDenied;
    }
    class AlreadyRegistered implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): AlreadyRegistered;
    }
    class NotEnoughWorkers implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): NotEnoughWorkers;
    }
    class QuotaExceeded implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): QuotaExceeded;
    }
    class NoSuchJob implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): NoSuchJob;
    }
    class DatasetRequestsFailed implements oasis.AbiEncodable {
        0: [oasis.Address, DatasetRequestError][];
        constructor(arg0: [oasis.Address, DatasetRequestError][]);
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): DatasetRequestsFailed;
    }
    class Deactivated implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Deactivated;
    }
    class InvalidJobCompletionStatus implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): InvalidJobCompletionStatus;
    }
    function abiDecode(decoder: oasis.Decoder): Error;
    const VARIANTS: Function[];
    function isVariant(obj: any): obj is Error;
}
export declare type Error = Error.PermissionDenied | Error.AlreadyRegistered | Error.NotEnoughWorkers | Error.QuotaExceeded | Error.NoSuchJob | Error.DatasetRequestsFailed | Error.Deactivated | Error.InvalidJobCompletionStatus;
export declare module DatasetRequestError {
    class Unreachable implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Unreachable;
    }
    class DatasetError implements oasis.AbiEncodable {
        0: dataset.Error;
        constructor(arg0: dataset.Error);
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): DatasetError;
    }
    function abiDecode(decoder: oasis.Decoder): DatasetRequestError;
    const VARIANTS: Function[];
    function isVariant(obj: any): obj is DatasetRequestError;
}
export declare type DatasetRequestError = DatasetRequestError.Unreachable | DatasetRequestError.DatasetError;
export declare class Bytes implements oasis.AbiEncodable {
    0: Uint8Array;
    constructor(arg0: Uint8Array);
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): Bytes;
}
export declare class Dispatcher {
    readonly address: oasis.Address;
    private gateway;
    static BYTECODE: string;
    private constructor();
    static connect(address: oasis.Address, gateway: oasis.Gateway): Promise<Dispatcher>;
    static deploy(gateway: oasis.Gateway, { executor }: {
        executor: oasis.Address;
    }, options?: oasis.DeployOptions): Promise<Dispatcher>;
    private static makeDeployPayload;
    submitJob({ job }: {
        job: JobRequest;
    }, options?: oasis.RpcOptions): Promise<Uint8Array>;
    private static makeSubmitJobPayload;
    getQuota(options?: oasis.RpcOptions): Promise<number>;
    private static makeGetQuotaPayload;
    getPendingJobIds(options?: oasis.RpcOptions): Promise<Uint8Array[]>;
    private static makeGetPendingJobIdsPayload;
    getPendingJobs(options?: oasis.RpcOptions): Promise<JobSubmitted[]>;
    private static makeGetPendingJobsPayload;
    getPendingJobsById({ jobIds }: {
        jobIds: Uint8Array[];
    }, options?: oasis.RpcOptions): Promise<JobSubmitted[]>;
    private static makeGetPendingJobsByIdPayload;
    retrieveSecrets({ jobId }: {
        jobId: Uint8Array;
    }, options?: oasis.RpcOptions): Promise<Secrets>;
    private static makeRetrieveSecretsPayload;
    completeJob({ jobId, status, outputs, info, }: {
        jobId: Uint8Array;
        status: JobCompletionStatus;
        outputs: OutputDataset[];
        info: string;
    }, options?: oasis.RpcOptions): Promise<void>;
    private static makeCompleteJobPayload;
    increaseQuota({ entity, amount }: {
        entity: oasis.Address;
        amount: number;
    }, options?: oasis.RpcOptions): Promise<void>;
    private static makeIncreaseQuotaPayload;
    getQuotaOf({ entity }: {
        entity: oasis.Address;
    }, options?: oasis.RpcOptions): Promise<number>;
    private static makeGetQuotaOfPayload;
    deactivate(options?: oasis.RpcOptions): Promise<void>;
    private static makeDeactivatePayload;
}
