import * as oasis from 'oasis-std';
export declare class DeployCode implements oasis.AbiEncodable {
    0: Uint8Array;
    constructor(arg0: Uint8Array);
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): DeployCode;
}
export declare class BlanketPolicyFilter implements oasis.AbiEncodable {
    params: BlanketPolicyParams;
    priority: number;
    constructor(fields: {
        params: BlanketPolicyParams;
        priority: number;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): BlanketPolicyFilter;
}
export declare class BlanketPolicyParams implements oasis.AbiEncodable {
    creator?: oasis.Address | undefined;
    constructor(fields: {
        creator?: oasis.Address | undefined;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): BlanketPolicyParams;
}
export declare class IdentityCreated implements oasis.AbiEncodable {
    constructor(fields: {});
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): IdentityCreated;
    static subscribe(gateway: oasis.Gateway, address: oasis.Address | null): Promise<oasis.Subscription<IdentityCreated>>;
}
export declare class IdentityDeactivated implements oasis.AbiEncodable {
    constructor(fields: {});
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): IdentityDeactivated;
    static subscribe(gateway: oasis.Gateway, address: oasis.Address | null): Promise<oasis.Subscription<IdentityDeactivated>>;
}
export declare class BlanketPolicyChanged implements oasis.AbiEncodable {
    filter: BlanketPolicyFilter;
    policy: oasis.Address;
    memo: Uint8Array;
    constructor(fields: {
        filter: BlanketPolicyFilter;
        policy: oasis.Address;
        memo: Uint8Array;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): BlanketPolicyChanged;
    static subscribe(gateway: oasis.Gateway, address: oasis.Address | null, topics?: {
        filter?: BlanketPolicyFilter;
        policy?: oasis.Address;
        memo?: Uint8Array;
    }): Promise<oasis.Subscription<BlanketPolicyChanged>>;
}
export declare module Error {
    class PermissionDenied implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): PermissionDenied;
    }
    class Deactivated implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Deactivated;
    }
    class Invocation implements oasis.AbiEncodable {
        0: InvocationError;
        constructor(arg0: InvocationError);
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Invocation;
    }
    function abiDecode(decoder: oasis.Decoder): Error;
    const VARIANTS: Function[];
    function isVariant(obj: any): obj is Error;
}
export declare type Error = Error.PermissionDenied | Error.Deactivated | Error.Invocation;
export declare module InvocationError {
    class InvalidInput implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): InvalidInput;
    }
    class InvalidCallee implements oasis.AbiEncodable {
        constructor();
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): InvalidCallee;
    }
    class Execution implements oasis.AbiEncodable {
        0: Uint8Array;
        constructor(arg0: Uint8Array);
        abiEncode(encoder: oasis.Encoder): void;
        static abiDecode(decoder: oasis.Decoder): Execution;
    }
    function abiDecode(decoder: oasis.Decoder): InvocationError;
    const VARIANTS: Function[];
    function isVariant(obj: any): obj is InvocationError;
}
export declare type InvocationError = InvocationError.InvalidInput | InvocationError.InvalidCallee | InvocationError.Execution;
export declare class PublicState implements oasis.AbiEncodable {
    trustedSenders: oasis.Set<oasis.Address>;
    blanketPolicies: [BlanketPolicyFilter, oasis.Address][];
    active: boolean;
    constructor(fields: {
        trustedSenders: oasis.Set<oasis.Address>;
        blanketPolicies: [BlanketPolicyFilter, oasis.Address][];
        active: boolean;
    });
    abiEncode(encoder: oasis.Encoder): void;
    static abiDecode(decoder: oasis.Decoder): PublicState;
}
export declare class Identity {
    readonly address: oasis.Address;
    private gateway;
    static BYTECODE: string;
    private constructor();
    static connect(address: oasis.Address, gateway: oasis.Gateway): Promise<Identity>;
    static deploy(gateway: oasis.Gateway, { trustedSenders }: {
        trustedSenders: oasis.Set<oasis.Address>;
    }, options?: oasis.DeployOptions): Promise<Identity>;
    private static makeDeployPayload;
    getPublicState(options?: oasis.RpcOptions): Promise<PublicState>;
    private static makeGetPublicStatePayload;
    spawn({ deployCode }: {
        deployCode: DeployCode;
    }, options?: oasis.RpcOptions): Promise<oasis.Result<oasis.Address, oasis.RpcError>>;
    private static makeSpawnPayload;
    invoke({ serviceAddr, message }: {
        serviceAddr: oasis.Address;
        message: Uint8Array;
    }, options?: oasis.RpcOptions): Promise<oasis.Result<Uint8Array, oasis.RpcError>>;
    private static makeInvokePayload;
    addBlanketPolicy({ filter, policy, memo, }: {
        filter: BlanketPolicyFilter;
        policy: oasis.Address;
        memo: Uint8Array;
    }, options?: oasis.RpcOptions): Promise<void>;
    private static makeAddBlanketPolicyPayload;
    removeBlanketPolicy({ filter }: {
        filter: BlanketPolicyFilter;
    }, options?: oasis.RpcOptions): Promise<void>;
    private static makeRemoveBlanketPolicyPayload;
    getBlanketPolicy({ params }: {
        params: BlanketPolicyParams;
    }, options?: oasis.RpcOptions): Promise<oasis.Address | undefined>;
    private static makeGetBlanketPolicyPayload;
    resetTrustedSenders({ newTrustedSenders }: {
        newTrustedSenders: oasis.Set<oasis.Address>;
    }, options?: oasis.RpcOptions): Promise<void>;
    private static makeResetTrustedSendersPayload;
    deactivate(options?: oasis.RpcOptions): Promise<void>;
    private static makeDeactivatePayload;
}
