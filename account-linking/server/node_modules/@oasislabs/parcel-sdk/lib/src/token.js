"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const url_1 = require("url");
const tweetnacl_1 = require("tweetnacl");
const axios_1 = __importDefault(require("axios"));
const crypto_1 = __importDefault(require("crypto"));
const jwk_to_pem_1 = __importDefault(require("jwk-to-pem"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
exports.PARCEL_AUD = 'https://api.oasislabs.com/parcel';
/**
 * A `TokenProvider` that always returns the same, initially provided token
 */
class StaticTokenProvider {
    constructor(token) {
        this.token = token;
    }
    getToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.token;
        });
    }
}
exports.StaticTokenProvider = StaticTokenProvider;
var TokenScope;
(function (TokenScope) {
    TokenScope["Api"] = "parcel.temp_api";
    TokenScope["Storage"] = "parcel.temp_storage";
    TokenScope["GCP"] = "https://www.googleapis.com/auth/devstorage.read_write";
})(TokenScope = exports.TokenScope || (exports.TokenScope = {}));
/**
 * A renewing token provider obtains a new access token when the current one has expired.
 */
/* Note: we could use the openid-client NPM package, but it's massive
 * overkill for what we want, which is simply `GET`ting the /token endpoint.
 */
class RenewingTokenProvider {
    constructor(tokenEndpoint, makeRefreshRequestParams, handleRefreshResponse = Token.fromResponse) {
        this.tokenEndpoint = tokenEndpoint;
        this.makeRefreshRequestParams = makeRefreshRequestParams;
        this.handleRefreshResponse = handleRefreshResponse;
        this.currentToken = new Token('', 0);
    }
    /**
     * Returns a new `RenewingTokenProvider` that obtains new access tokens to
     * https://api.oasislabs.com/parcel by presenting a client assertion to `tokenEndpoint`.
     * The client assertion token is signed using your API access token; you will need to
     * also provide your `clientId` and signing JWK.
     */
    static fromPrivateJWK({ clientId, privateKey, tokenEndpoint, scopes, expiresIn = '1h', }) {
        const privateJwk = JSON.parse(privateKey);
        if (privateJwk.kty !== 'EC') {
            throw new Error('Private key should be an ECDSA key.');
        }
        if (!privateJwk.kid) {
            privateJwk.kid = getKeyThumbprint(privateJwk);
        }
        const makeRefreshRequestParams = () => {
            const clientAssertion = jsonwebtoken_1.default.sign({}, jwk_to_pem_1.default(privateJwk, { private: true }), {
                subject: clientId,
                issuer: clientId,
                keyid: privateJwk.kid,
                algorithm: 'ES256',
                audience: tokenEndpoint,
                expiresIn: expiresIn,
                jwtid: buffer_1.Buffer.from(tweetnacl_1.randomBytes(8)).toString('base64'),
            });
            /* eslint-disable @typescript-eslint/camelcase */
            return {
                grant_type: 'client_credentials',
                scope: scopes.join(' '),
                audience: exports.PARCEL_AUD,
                client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
                client_assertion: clientAssertion,
            };
            /* eslint-enable @typescript-eslint/camelcase */
        };
        return new RenewingTokenProvider(tokenEndpoint, makeRefreshRequestParams);
    }
    /**
     * Returns a new `RenewingTokenProvider` that obtains new access tokens to
     * https://api.oasislabs.com/parcel by presenting a client assertion to `tokenEndpoint`.
     * The client assertion token is signed using your API access token; you will need to
     * also provide your `clientId` and client secret in PEM format.
     */
    static fromPrivatePEM({ clientId, clientSecret, tokenEndpoint, scopes, expiresIn = '1h', }) {
        const makeRefreshRequestParams = () => {
            const payload = {
                iss: clientId,
                scope: scopes.join(' '),
                aud: tokenEndpoint,
            };
            const clientAssertion = jsonwebtoken_1.default.sign(payload, clientSecret, {
                algorithm: 'RS256',
                expiresIn: expiresIn,
            });
            /* eslint-disable @typescript-eslint/camelcase */
            return {
                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                assertion: clientAssertion,
            };
            /* eslint-enable @typescript-eslint/camelcase */
        };
        return new RenewingTokenProvider(tokenEndpoint, makeRefreshRequestParams);
    }
    /**
     * Returns a new `RenewingTokenProvider` that obtains new access tokens
     * by presenting a non-expired refresh token.
     */
    static fromRefreshToken({ refreshToken, tokenEndpoint, }) {
        /* eslint-disable @typescript-eslint/camelcase */
        const makeRefreshRequestParams = () => {
            return {
                grant_type: 'refresh_token',
                refresh_token: refreshToken,
            };
        };
        const handleRefreshResponse = (resP) => __awaiter(this, void 0, void 0, function* () {
            const requestTime = Date.now();
            const { data: body } = yield resP.catch(handleErrorResponse);
            refreshToken = body.refresh_token;
            return Token.fromResponseBody(body, requestTime);
        });
        /* eslint-enable @typescript-eslint/camelcase */
        return new RenewingTokenProvider(tokenEndpoint, makeRefreshRequestParams, handleRefreshResponse);
    }
    getToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentToken.isExpired()) {
                this.currentToken = yield this.refreshToken();
            }
            return this.currentToken.token;
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const params = this.makeRefreshRequestParams();
            const form = new url_1.URLSearchParams();
            Object.keys(params).forEach((key) => {
                form.append(key, params[key]);
            });
            return this.handleRefreshResponse(axios_1.default.post(this.tokenEndpoint, form));
        });
    }
}
exports.RenewingTokenProvider = RenewingTokenProvider;
class Token {
    constructor(token, expiry) {
        this.token = token;
        this.expiry = expiry;
    }
    static fromResponse(resP) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield resP.catch(handleErrorResponse);
            return Token.fromResponseBody(res.data, Date.now());
        });
    }
    static fromResponseBody(
    /* eslint-disable @typescript-eslint/camelcase */
    { access_token: accessToken, expires_in: expiresIn, }, 
    /* eslint-enable @typescript-eslint/camelcase */
    requestTime) {
        return new Token(accessToken, requestTime + expiresIn * 1000);
    }
    isExpired() {
        return this.expiry <= Date.now();
    }
}
function handleErrorResponse(err) {
    var _a;
    if (err.response) {
        const res = err.response;
        const cloudflareError = (_a = JSON.stringify(res.data).match(/class="cf-error-code">(.*)</)) === null || _a === void 0 ? void 0 : _a[1];
        const cloudflareHint = ['1006', '1007', '1008'].includes(cloudflareError)
            ? 'Do you need to use VPN?'
            : '';
        const maybeCloudflare = cloudflareError
            ? `(Cloudflare error code: ${cloudflareError}. ${cloudflareHint})`
            : '';
        throw new Error(`auth token fetch failed with status ${res.status} ${maybeCloudflare}`);
    }
    else {
        throw err;
    }
}
function getKeyThumbprint(jwk) {
    const json = JSON.stringify({
        crv: jwk.crv,
        kty: jwk.kty,
        x: jwk.x,
        y: jwk.y,
    }, 
    // Keys should be stringified in an alphabetical order.
    ['crv', 'kty', 'x', 'y']);
    const digest = crypto_1.default.createHash('sha256').update(json).digest();
    // base64url encoding.
    return digest.toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
//# sourceMappingURL=token.js.map