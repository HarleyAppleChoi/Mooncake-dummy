"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscription = exports.Gateway = void 0;
const common_1 = require("@oasislabs/common");
const confidential_1 = require("@oasislabs/confidential");
const gateway_1 = require("@oasislabs/gateway");
const service_1 = require("@oasislabs/service");
const logging_1 = require("./logging");
const types_1 = require("./types");
const utils_1 = require("./utils");
/**
 * The `Gateway` class allows clients to make requests of the Oasis Developer Gateway.
 */
class Gateway {
    constructor(url, apiToken, headers = new Map()) {
        this.url = url;
        this.apiToken = apiToken;
        this.headers = headers;
        this.subscriptionId = 0;
        this.inner = new gateway_1.HttpGateway(url, apiToken, { headers });
        this.keyStore = new confidential_1.KeyStore(new common_1.LocalStorage(), this.inner);
        this.log = logging_1.oasisLogger('oasis-std-gateway-client');
    }
    /**
     * Deploy a new confidential service.
     * `payload` should be the service bytecode followed by the constructor stdin.
     * @returns a promise that resolves to the address of the newly-created service.
     */
    deploy(payload, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.inner.deploy({
                    data: Gateway.makeDeployCode(payload, options),
                });
                return new types_1.Address(res.address);
            }
            catch (e) {
                let parsedErr;
                try {
                    parsedErr = yield Gateway.convertError(e);
                }
                catch (eParse) {
                    parsedErr = new types_1.RpcError.Gateway(`(Failed to parse error; parsing error: ${JSON.stringify(eParse)}; unparsed error: ${JSON.stringify(e)})`);
                }
                this.log.error({ err: parsedErr, rawErr: e }, 'Failed to deploy service');
                throw parsedErr;
            }
        });
    }
    static makeDeployCode(payload, options) {
        return service_1.DeployHeader.deployCode({ confidential: true, expiry: options === null || options === void 0 ? void 0 : options.expiry }, payload);
    }
    /**
     * Calls a confidential service deployed at `address` with `payload` as stdin.
     * Optional `headers` override those passed to the `Gateway` constructor.
     * @returns a promise that resolves to the service stdout or rejects with an `RpcError`.
     */
    rpc(address, payload, options, headers = new Map()) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const servicePublicKey = yield this.keyStore.publicKey(new common_1.Address(address.bytes));
            const clientKeys = this.keyStore.localKeys();
            const data = yield confidential_1.encrypt(confidential_1.nonce(), payload, servicePublicKey, clientKeys.publicKey, clientKeys.privateKey, (_a = options === null || options === void 0 ? void 0 : options.aad) !== null && _a !== void 0 ? _a : new Uint8Array());
            const decryptToBuffer = (bytes) => __awaiter(this, void 0, void 0, function* () {
                return utils_1.typedArrayToBuffer((yield confidential_1.decrypt(bytes, clientKeys.privateKey)).plaintext);
            });
            try {
                const res = yield this.withHeaders(headers, () => {
                    return this.inner.rpc({
                        address: address.bytes,
                        data,
                    });
                });
                if (res.error) {
                    // Should never happen; in case of errors, `this.inner.rpc()` should
                    // throw an Error, not return a result with `error` field filled out.
                    throw new types_1.RpcError.Gateway('Delegated inner RPC failed: ' + JSON.stringify(res.error));
                }
                return decryptToBuffer(utils_1.decodeHex(res.output));
            }
            catch (e) {
                let parsedErr;
                try {
                    parsedErr = yield Gateway.convertError(e, decryptToBuffer);
                }
                catch (eParse) {
                    parsedErr = new types_1.RpcError.Gateway(`(Failed to parse error; parsing error: ${JSON.stringify(eParse)}; unparsed error: ${JSON.stringify(e)})`);
                }
                this.log.error({
                    err: parsedErr,
                    rawErr: e,
                    stack: logging_1.stackTrace(),
                }, 'Failed to make RPC');
                throw parsedErr;
            }
        });
    }
    /**
     * Monkey-patches the headers on the inner `HttpGateway` for a single request, `req`.
     * The code in `req` must be  entirely synchronous to ensure that the additional headers
     * are unset in time for the next request.
     */
    withHeaders(headers, req) {
        const sessionHeaders = this
            .inner.session.headers;
        const origHeaders = sessionHeaders.headers;
        const mergedHeaders = new Map(origHeaders);
        for (const [k, v] of headers) {
            mergedHeaders.set(k, v);
        }
        sessionHeaders.headers = mergedHeaders;
        const res = req();
        sessionHeaders.headers = origHeaders;
        return res;
    }
    static convertError(e, decoder = (output) => __awaiter(this, void 0, void 0, function* () { return output; })) {
        return __awaiter(this, void 0, void 0, function* () {
            const execErrRe = /transaction execution failure with error (?:0x)?([0-9A-Fa-f]*)"}}$/;
            const execErrMatch = execErrRe.exec(e.toString());
            if (execErrMatch) {
                const execErrBytes = yield decoder(utils_1.decodeHex(execErrMatch[1]));
                return new types_1.RpcError.Execution(execErrBytes);
            }
            return new types_1.RpcError.Gateway(e);
        });
    }
    /**
     * Subscribes to events emitted by the service at `address` that contain
     * all of the provided `topics` and for which `filter` returns true.
     */
    subscribe(address, topics, decoder, filter = (_) => true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.subscriptionId += 1;
            const sub = new Subscription(this.subscriptionId.toString(), yield this.inner
                .subscribe({
                event: this.subscriptionId.toString(),
                filter: {
                    address: address === null || address === void 0 ? void 0 : address.bytes,
                    topics,
                },
            })
                .catch(wrapError), decoder, filter, this);
            return sub;
        });
    }
    /**
     * Cancels a previous subscription named `subscriptionName`.
     */
    unsubscribe(subscriptionName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.inner
                .unsubscribe({ event: subscriptionName })
                .catch(wrapError);
        });
    }
    /**
     * @returns a promise that resolves to the bytecode present at `address`. Rejects
     * if there is no service at `address` or there is no bytecode (i.e. the address is an
     * externally-owned account).
     */
    getCode(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const { code: deploycode } = yield this.inner
                .getCode({
                address: address.bytes,
            })
                .catch(wrapError);
            if (deploycode === null || deploycode.length === 0) {
                throw new types_1.RpcError.Gateway(`no bytecode for service at ${address.hex}`);
            }
            return service_1.DeployHeaderReader.initcode(deploycode);
        });
    }
    /**
     * @returns a promise that resolves to the public key of the service at `address`.
     * Rejects if there is no service at `address`.
     */
    getPublicKey(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKey } = yield this.inner
                .publicKey({
                address: address.bytes,
            })
                .catch(wrapError);
            if (typeof publicKey === 'undefined') {
                /* istanbul ignore next */ // pubkey is derived from addr, so always exists
                throw new types_1.RpcError.Gateway(`could not get public key of service at ${address.hex}`);
            }
            return publicKey;
        });
    }
    /**
     * Returns the expiry timestamp (in seconds) of the service at `address`, if it exists.
     */
    getExpiry(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const { expiry } = yield this.inner
                .expiry({ address: address.bytes })
                .catch(wrapError);
            return expiry;
        });
    }
    /**
     * Disconnects this gateway from the backend server.
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.inner.disconnect().catch(wrapError);
        });
    }
}
exports.Gateway = Gateway;
/**
 * Wrapper around a Promise that exposes its `resolve`/`reject` methods.
 * Intended for async signaling: If this object is shared between two
 * sections of code, one section can signal the other section by calling
 * `resolve()` on the object, while the other section `await`s the `promise`.
 */
class ExternallySettledPromise {
    constructor() {
        this.promise = new Promise((resolve_, reject_) => {
            this.resolve = resolve_;
            this.reject = reject_;
        });
    }
}
/**
 * A class that represents an event-emiting object (with `.on(...)` API)
 * as an async iterable (with `for await (... of ...)` API).
 * It also provides hooks for event transformation (e.g. ABI decoding) and filtering.
 */
class Subscription {
    /**
     * @param name The event to listen to from `emitter`.
     * @param emitter Events from this object will be exposed.
     * @param decoder Each event will be deserialized with this function before being exposed.
     * @param filter Only events for which the filter returns true (after deserialization) will be exposed.
     * @param gateway Once the output iterator terminates, we'll unsubscribe from events from this gateway.
     *                The assumption is that `emitter` generates events from `gateway`.
     */
    constructor(name, emitter, decoder, filter, gateway) {
        this.name = name;
        this.gateway = gateway;
        // Events that have accumulated between successive calls to `[Symbol.asyncIterator]`
        this.events = [];
        // Signalling mechanism between event-ingesting part and iterator interface.
        this.hasResults = new ExternallySettledPromise();
        emitter
            .on(name, ({ data }) => __awaiter(this, void 0, void 0, function* () {
            const decodedData = yield decoder(utils_1.decodeHex(data));
            if (!filter(decodedData))
                return;
            this.events.push(decodedData);
            this.hasResults.resolve();
            this.hasResults = new ExternallySettledPromise();
        }))
            .on('error', (e) => {
            this.hasResults.reject(new types_1.RpcError.Gateway(e));
            this.hasResults = new ExternallySettledPromise();
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            try {
                while (true) {
                    if (this.events.length > 0) {
                        yield __await(yield* __asyncDelegator(__asyncValues(this.events)));
                        this.events = [];
                    }
                    yield __await(this.hasResults.promise);
                    yield __await(yield* __asyncDelegator(__asyncValues(this.events)));
                    this.events = [];
                }
            }
            finally {
                yield __await(this.gateway['unsubscribe'](this.name));
            }
        });
    }
    // Returns a Promise that resolves to the first event. After that, the
    // subscription automatically ends.
    first() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _b = __asyncValues(this), _c; _c = yield _b.next(), !_c.done;) {
                    const event = _c.value;
                    return event;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            /* istanbul ignore next */
            throw new Error('Subscription closed before the first event');
        });
    }
}
exports.Subscription = Subscription;
function wrapError(e) {
    return Promise.reject(new types_1.RpcError.Gateway(e));
}
//# sourceMappingURL=gateway.js.map