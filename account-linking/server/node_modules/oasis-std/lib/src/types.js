"use strict";
/* eslint-disable no-inner-declarations, @typescript-eslint/no-namespace */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OasisSet = exports.OasisMap = exports.Result = exports.RpcError = exports.Balance = exports.Address = void 0;
const utils_1 = require("./utils");
const abi_1 = require("./abi");
/**
 * Lightweight wrapper for bytes with an easy hex conversion.
 */
class Bytes {
    constructor(bytes) {
        if (bytes.length !== this.expectedLength()) {
            throw new Error(`invalid length: expected ${this.expectedLength()} bytes, got ${bytes.length} bytes.`);
        }
        this._bytes = bytes;
    }
    /** Returns the bytes representation of this object. */
    get bytes() {
        return this._bytes;
    }
    /** Returns the hex representation of this object. */
    get hex() {
        if (typeof this._hex === 'undefined') {
            this._hex = utils_1.encodeHex(this._bytes);
        }
        return this._hex;
    }
    abiEncode(encoder) {
        encoder.writeU8Array(this.bytes);
    }
    equals(other) {
        for (let i = 0; i < this.expectedLength(); i++) {
            if (other._bytes[i] !== this._bytes[i]) {
                return false;
            }
        }
        return true;
    }
    toJSON() {
        return JSON.stringify(this.hex);
    }
}
/**
 * A 20-byte Oasis account address. May be hex-encoded.
 */
class Address extends Bytes {
    constructor(repr) {
        if (typeof repr === 'string') {
            super(utils_1.decodeHex(repr));
            this._hex =
                (repr.startsWith('0x') ? '' : '0x') + repr.toLowerCase();
        }
        else {
            super(repr);
        }
    }
    expectedLength() {
        return Address.LENGTH;
    }
    static abiDecode(decoder) {
        return new Address(decoder.readU8Array(Address.LENGTH));
    }
    static fromJSON(json) {
        return new Address(JSON.parse(json));
    }
}
exports.Address = Address;
Address.LENGTH = 20;
/**
 * An Oasis account balance.
 * JS `Number`s do not have sufficient precision so you should prefer to represent the balance
 * as (big-endian) hex, a `BigInt`, or raw `Uint8Array`.
 */
class Balance extends Bytes {
    constructor(repr) {
        if (typeof repr === 'number') {
            repr = BigInt(repr);
        }
        if (typeof repr === 'bigint') {
            const preBytes = new BigInt64Array([repr, BigInt(0)]);
            //^ more efficient than stringifying
            super(new Uint8Array(preBytes.buffer, preBytes.byteOffset, Balance.LENGTH));
        }
        else if (typeof repr === 'string') {
            const parsed = utils_1.decodeHex(repr);
            const balanceBytes = new Uint8Array(Math.max(parsed.length, 16));
            for (let i = 0; i < parsed.length; i++) {
                balanceBytes[i] = parsed[parsed.length - i - 1]; // big -> little endian
            }
            super(balanceBytes);
            repr = repr.startsWith('0x') ? repr.slice(2) : repr;
            repr = repr.replace(/^0+/, '');
            repr = repr.length % 2 == 0 ? repr : '0' + repr;
            this._hex = '0x' + repr.toLowerCase();
        }
        else {
            super(repr);
        }
    }
    expectedLength() {
        return Balance.LENGTH;
    }
    static abiDecode(decoder) {
        return new Balance(decoder.readU8Array(Balance.LENGTH));
    }
    get hex() {
        if (typeof this._hex === 'undefined') {
            // convert to big endian for display
            const beBytes = new Uint8Array(Balance.LENGTH);
            let numPrintableBytes = 0;
            for (let i = this._bytes.length - 1; i >= 0; i--) {
                const leByte = this._bytes[i];
                if (leByte === 0 && numPrintableBytes === 0) {
                    continue;
                }
                beBytes[numPrintableBytes] = leByte;
                numPrintableBytes += 1;
            }
            this._hex = utils_1.encodeHex(beBytes.subarray(0, numPrintableBytes));
        }
        return this._hex;
    }
    static fromJSON(json) {
        return new Balance(JSON.parse(json));
    }
}
exports.Balance = Balance;
Balance.LENGTH = 16; // 128 bits
/**
 * TypeScript definition of RpcEror to match the Rust enum in oasis-types v0.4.
 */
var RpcError;
(function (RpcError) {
    class InvalidCallee {
        abiEncode(encoder) {
            encoder.writeU8(0);
        }
        static abiDecode(_decoder) {
            return new InvalidCallee();
        }
    }
    RpcError.InvalidCallee = InvalidCallee;
    class InsufficientFunds {
        abiEncode(encoder) {
            encoder.writeU8(1);
        }
        static abiDecode(_decoder) {
            return new InsufficientFunds();
        }
    }
    RpcError.InsufficientFunds = InsufficientFunds;
    class InsufficientGas {
        abiEncode(encoder) {
            encoder.writeU8(2);
        }
        static abiDecode(_decoder) {
            return new InsufficientGas();
        }
    }
    RpcError.InsufficientGas = InsufficientGas;
    class InvalidInput {
        abiEncode(encoder) {
            encoder.writeU8(3);
        }
        static abiDecode(_decoder) {
            return new InvalidInput();
        }
    }
    RpcError.InvalidInput = InvalidInput;
    class InvalidOutput {
        constructor(output) {
            this[0] = output;
        }
        abiEncode(encoder) {
            encoder.writeU8(4);
            abi_1.abiEncode(['u8', Number.POSITIVE_INFINITY], this[0], encoder);
        }
        static abiDecode(decoder) {
            return new InvalidOutput(abi_1.abiDecode(['u8', Number.POSITIVE_INFINITY], decoder));
        }
    }
    RpcError.InvalidOutput = InvalidOutput;
    class Execution {
        constructor(output) {
            this[0] = output;
        }
        abiEncode(encoder) {
            encoder.writeU8(5);
            abi_1.abiEncode(['u8', Number.POSITIVE_INFINITY], this[0], encoder);
        }
        static abiDecode(decoder) {
            return new Execution(abi_1.abiDecode(['u8', Number.POSITIVE_INFINITY], decoder));
        }
    }
    RpcError.Execution = Execution;
    class Gateway {
        constructor(error) {
            this[0] = error;
        }
        abiEncode(encoder) {
            encoder.writeU8(6);
            abi_1.abiEncode('string', this[0], encoder);
        }
        static abiDecode(decoder) {
            return new Gateway(abi_1.abiDecode('string', decoder));
        }
    }
    RpcError.Gateway = Gateway;
    RpcError.VARIANTS = [
        InvalidCallee,
        InsufficientFunds,
        InsufficientGas,
        InvalidInput,
        InvalidOutput,
        Execution,
        Gateway,
    ];
    function isVariant(obj) {
        for (const variant of RpcError.VARIANTS) {
            if (obj instanceof variant) {
                return true;
            }
        }
        return false;
    }
    RpcError.isVariant = isVariant;
    function abiDecode(decoder) {
        const variantId = decoder.readU8();
        return abi_1.abiDecode(RpcError.VARIANTS[variantId], decoder);
    }
    RpcError.abiDecode = abiDecode;
})(RpcError = exports.RpcError || (exports.RpcError = {}));
var Result;
(function (Result) {
    class Ok {
        constructor(val) {
            this.val = val;
        }
        isOk() {
            return true;
        }
        isErr() {
            return false;
        }
        unwrap() {
            return this.val;
        }
        unwrapErr() {
            throw new Error('tried to unwrapErr Ok');
        }
    }
    Result.Ok = Ok;
    class Err {
        constructor(val) {
            this.val = val;
        }
        isOk() {
            return false;
        }
        isErr() {
            return true;
        }
        unwrap() {
            throw new Error('tried to unwrap Err');
        }
        unwrapErr() {
            return this.val;
        }
    }
    Result.Err = Err;
})(Result = exports.Result || (exports.Result = {}));
class MapLike {
    constructor(items = []) {
        this.inner = {};
        for (const [k, v] of items) {
            this._set(k, v);
        }
    }
    get size() {
        return Object.keys(this.inner).length;
    }
    has(key) {
        return this._get(key) !== undefined;
    }
    delete(key) {
        delete this.inner[JSON.stringify(key)];
    }
    clear() {
        this.inner = {};
    }
    *keys() {
        for (const entry of this._entries()) {
            yield entry[0];
        }
    }
    _get(key) {
        const v = this.inner[JSON.stringify(key)];
        return v ? v[1] : undefined;
    }
    _set(key, value) {
        this.inner[JSON.stringify(key)] = [key, value];
    }
    *_entries() {
        for (const entry of Object.values(this.inner)) {
            yield entry;
        }
    }
}
/**
 * A `Map` type that's used by the Oasis ABI. Its primary purpose is to contain POD keys
 * (i.e. those that do not have user-defined methods and are represenable solely through JSON).
 * Equality in this type is defined as equality of JSON representations.
 */
class OasisMap extends MapLike {
    get(key) {
        return this._get(key);
    }
    set(key, value) {
        this._set(key, value);
    }
    *entries() {
        yield* this._entries();
    }
    *values() {
        for (const [_, v] of this._entries()) {
            yield v;
        }
    }
    *[Symbol.iterator]() {
        yield* this.entries();
    }
}
exports.OasisMap = OasisMap;
/**
 * A `Set` type that's used by the Oasis ABI. Its primary purpose is to contain POD types
 * (i.e. those that do not have user-defined methods and are represenable solely through JSON).
 * Equality in this type is defined as equality of JSON representations.
 */
class OasisSet extends MapLike {
    constructor(items = []) {
        super(items.map((item) => [item, true]));
    }
    add(item) {
        this._set(item, true);
    }
    *entries() {
        for (const entry of this._entries()) {
            yield [entry[0], entry[0]];
        }
    }
    *values() {
        yield* this.keys();
    }
    *[Symbol.iterator]() {
        yield* this.values();
    }
}
exports.OasisSet = OasisSet;
//# sourceMappingURL=types.js.map