import { AbiDecodable, AbiEncodable, Encoder, Decoder } from './abi';
/**
 * Lightweight wrapper for bytes with an easy hex conversion.
 */
declare abstract class Bytes {
    protected _bytes: Uint8Array;
    protected _hex: string | undefined;
    protected constructor(bytes: Uint8Array);
    /** Returns the bytes representation of this object. */
    get bytes(): Uint8Array;
    /** Returns the hex representation of this object. */
    get hex(): string;
    abiEncode(encoder: Encoder): void;
    protected abstract expectedLength(): number;
    equals(other: this): boolean;
    toJSON(): string;
}
/**
 * A 20-byte Oasis account address. May be hex-encoded.
 */
export declare class Address extends Bytes implements AbiEncodable {
    static LENGTH: number;
    constructor(repr: string | Uint8Array);
    protected expectedLength(): number;
    static abiDecode(decoder: Decoder): Address;
    static fromJSON(json: string): Address;
}
/**
 * An Oasis account balance.
 * JS `Number`s do not have sufficient precision so you should prefer to represent the balance
 * as (big-endian) hex, a `BigInt`, or raw `Uint8Array`.
 */
export declare class Balance extends Bytes implements AbiEncodable {
    static LENGTH: number;
    constructor(repr: string | bigint | number | Uint8Array);
    protected expectedLength(): number;
    static abiDecode(decoder: Decoder): Balance;
    get hex(): string;
    static fromJSON(json: string): Balance;
}
/**
 * TypeScript definition of RpcEror to match the Rust enum in oasis-types v0.4.
 */
export declare namespace RpcError {
    class InvalidCallee implements AbiEncodable {
        abiEncode(encoder: Encoder): void;
        static abiDecode(_decoder: Decoder): InvalidCallee;
    }
    class InsufficientFunds implements AbiEncodable {
        abiEncode(encoder: Encoder): void;
        static abiDecode(_decoder: Decoder): InsufficientFunds;
    }
    class InsufficientGas implements AbiEncodable {
        abiEncode(encoder: Encoder): void;
        static abiDecode(_decoder: Decoder): InsufficientGas;
    }
    class InvalidInput implements AbiEncodable {
        abiEncode(encoder: Encoder): void;
        static abiDecode(_decoder: Decoder): InvalidInput;
    }
    class InvalidOutput implements AbiEncodable {
        0: Uint8Array;
        constructor(output: Uint8Array);
        abiEncode(encoder: Encoder): void;
        static abiDecode(decoder: Decoder): InvalidOutput;
    }
    class Execution implements AbiEncodable {
        0: Uint8Array;
        constructor(output: Uint8Array);
        abiEncode(encoder: Encoder): void;
        static abiDecode(decoder: Decoder): Execution;
    }
    class Gateway implements AbiEncodable {
        0: any;
        constructor(error: any);
        abiEncode(encoder: Encoder): void;
        static abiDecode(decoder: Decoder): Gateway;
    }
    const VARIANTS: (Function & AbiDecodable)[];
    function isVariant(obj: any): obj is RpcError;
    function abiDecode(decoder: Decoder): RpcError;
}
export declare type RpcError = RpcError.InvalidCallee | RpcError.InsufficientFunds | RpcError.InsufficientGas | RpcError.InvalidInput | RpcError.InvalidOutput | RpcError.Execution | RpcError.Gateway;
export declare namespace Result {
    interface Result<T, E> {
        isOk(): boolean;
        isErr(): boolean;
        unwrap(): T;
        unwrapErr(): E;
    }
    export class Ok<T, E> implements Result<T, E> {
        private val;
        constructor(val: T);
        isOk(): boolean;
        isErr(): boolean;
        unwrap(): T;
        unwrapErr(): E;
    }
    export class Err<T, E> implements Result<T, E> {
        private val;
        constructor(val: E);
        isOk(): boolean;
        isErr(): boolean;
        unwrap(): T;
        unwrapErr(): E;
    }
    export {};
}
export declare type Result<T, E> = Result.Ok<T, E> | Result.Err<T, E>;
declare class MapLike<K, V> {
    protected inner: {
        [key: string]: [K, V];
    };
    constructor(items?: [K, V][]);
    get size(): number;
    has(key: K): boolean;
    delete(key: K): void;
    clear(): void;
    keys(): IterableIterator<K>;
    protected _get(key: K): V | undefined;
    protected _set(key: K, value: V): void;
    protected _entries(): IterableIterator<[K, V]>;
}
/**
 * A `Map` type that's used by the Oasis ABI. Its primary purpose is to contain POD keys
 * (i.e. those that do not have user-defined methods and are represenable solely through JSON).
 * Equality in this type is defined as equality of JSON representations.
 */
export declare class OasisMap<K, V> extends MapLike<K, V> {
    get(key: K): V | undefined;
    set(key: K, value: V): void;
    entries(): IterableIterator<[K, V]>;
    values(): IterableIterator<V>;
    [Symbol.iterator](): Iterator<[K, V]>;
}
/**
 * A `Set` type that's used by the Oasis ABI. Its primary purpose is to contain POD types
 * (i.e. those that do not have user-defined methods and are represenable solely through JSON).
 * Equality in this type is defined as equality of JSON representations.
 */
export declare class OasisSet<T> extends MapLike<T, true> {
    constructor(items?: T[]);
    add(item: T): void;
    entries(): IterableIterator<[T, T]>;
    values(): IterableIterator<T>;
    [Symbol.iterator](): Iterator<T>;
}
export {};
