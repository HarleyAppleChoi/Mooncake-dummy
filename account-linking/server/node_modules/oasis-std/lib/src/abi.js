"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeEventTopic = exports.typedArraySchemaType = exports.Decoder = exports.Encoder = exports.doAbiDecode = exports.abiDecode = exports.abiEncode = void 0;
const buffer_1 = require("buffer");
const js_sha3_1 = require("js-sha3");
const types_1 = require("./types");
const utils_1 = require("./utils");
function isSchemaArray(schema) {
    return (Array.isArray(schema) &&
        schema.length === 2 &&
        typeof schema[1] === 'number');
}
function assertSchemaIsTuple(_schema) {
    return true;
}
function stringifySchema(schema) {
    if (typeof schema === 'string') {
        return schema;
    }
    if (Array.isArray(schema)) {
        if (schema[0] === 'Set') {
            return `Set<${stringifySchema(schema[1])}>`;
        }
        if (schema[0] === 'Map') {
            const kTy = stringifySchema(schema[1]);
            const vTy = stringifySchema(schema[2]);
            return `Map<${kTy}, ${vTy}>`;
        }
        if (schema[0] === 'Option') {
            return `(${stringifySchema(schema[1])} | undefined)`;
        }
        if (schema[0] === 'Result') {
            const okTy = stringifySchema(schema[1]);
            const errTy = stringifySchema(schema[2]);
            return `Result<${okTy}, ${errTy}>`;
        }
        if (isSchemaArray(schema)) {
            // array
            const count = schema[1];
            if (count === Number.POSITIVE_INFINITY) {
                return `${stringifySchema(schema[0])}[]`;
            }
            return `${stringifySchema(schema[0])}[${count}]`;
        }
        if (assertSchemaIsTuple(schema)) {
            return `(${schema.map(stringifySchema).join(', ')})`; // tuple
        }
        /* istanbul ignore next */
        utils_1.unreachable(schema, `unknown schema: \`${schema}\``);
    }
    return schema.constructor.name;
}
/**
 * ABI encodes an object according to the provided schema.
 * @returns the encoded bytes
 */
function abiEncode(schema, obj, encoder) {
    encoder = encoder !== null && encoder !== void 0 ? encoder : new Encoder();
    doAbiEncode(schema, obj, encoder);
    return encoder.finish();
}
exports.abiEncode = abiEncode;
function doAbiEncode(schema, obj, encoder, parentTy) {
    var _a, _b, _c, _d, _e, _f;
    function throwUnexpectedType() {
        var _a;
        let got;
        if (obj === null)
            got = 'null';
        else if (obj === undefined)
            got = 'undefined';
        else
            got = (_a = obj.name) !== null && _a !== void 0 ? _a : obj.constructor.name;
        const schemaStr = stringifySchema(schema);
        const expected = typeof parentTy !== 'undefined' ? parentTy(schemaStr) : schemaStr;
        throw new Error(`unexpected type \`${got}\`. expected \`${expected}\``);
    }
    if (typeof schema === 'string') {
        const ty = schema;
        if (ty === 'void') {
            if (typeof obj === 'undefined' || obj === null) {
                return;
            }
            throwUnexpectedType();
        }
        if (ty === 'boolean') {
            if (typeof obj === 'boolean') {
                return encoder.writeBoolean(obj);
            }
            else {
                throwUnexpectedType();
            }
        }
        if (ty === 'string') {
            if (typeof obj === 'string') {
                return encoder.writeString(obj);
            }
            else {
                throwUnexpectedType();
            }
        }
        if (typeof obj !== 'number' && typeof obj !== 'bigint') {
            throwUnexpectedType();
        }
        if (ty === 'u64')
            return encoder.writeU64(BigInt(obj));
        if (ty === 'i64')
            return encoder.writeI64(BigInt(obj));
        if (ty === 'u128')
            return encoder.writeU128(BigInt(obj));
        if (ty === 'i128')
            return encoder.writeI128(BigInt(obj));
        const unsafeBigInt = Number(obj) != obj;
        if (typeof obj !== 'number' && unsafeBigInt) {
            /* istanbul ignore next */
            throwUnexpectedType();
        }
        if (ty === 'u8')
            return encoder.writeU8(Number(obj));
        if (ty === 'i8')
            return encoder.writeI8(Number(obj));
        if (ty === 'u16')
            return encoder.writeU16(Number(obj));
        if (ty === 'i16')
            return encoder.writeI16(Number(obj));
        if (ty === 'u32')
            return encoder.writeU32(Number(obj));
        if (ty === 'i32')
            return encoder.writeI32(Number(obj));
        if (ty === 'f32')
            return encoder.writeF32(Number(obj));
        if (ty === 'f64')
            return encoder.writeF64(Number(obj));
        utils_1.unreachable(ty, `unknown schema type: \`${ty}\``);
    }
    else if (Array.isArray(schema)) {
        if (schema[0] === 'Map') {
            const [_, keyTy, valTy] = schema;
            let entries;
            if (obj instanceof Map ||
                obj instanceof types_1.OasisMap ||
                (obj && ((_a = obj === null || obj === void 0 ? void 0 : obj.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'OasisMap')) {
                entries = [...obj.entries()];
            }
            else {
                throwUnexpectedType();
            }
            entries.sort();
            encoder.writeU32(entries.length);
            for (const [k, v] of entries) {
                doAbiEncode(keyTy, k, encoder);
                doAbiEncode(valTy, v, encoder);
            }
        }
        else if (schema[0] === 'Set') {
            const ty = schema[1];
            let keys;
            if (obj instanceof Set ||
                obj instanceof types_1.OasisSet ||
                (obj && ((_b = obj === null || obj === void 0 ? void 0 : obj.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'OasisSet')) {
                keys = [...obj.keys()];
            }
            else if (Array.isArray(obj)) {
                keys = obj;
            }
            else {
                throwUnexpectedType();
            }
            keys.sort();
            encoder.writeU32(keys.length);
            keys.forEach((key) => {
                doAbiEncode(ty, key, encoder);
            });
        }
        else if (schema[0] === 'Option') {
            const ty = schema[1];
            const isPresent = typeof obj !== 'undefined' && obj !== null;
            encoder.writeBoolean(isPresent);
            if (isPresent) {
                doAbiEncode(ty, obj, encoder, (ty) => `${ty} | undefined`);
            }
        }
        else if (schema[0] === 'Result') {
            const [_, okTy, errTy] = schema;
            if (typeof (obj === null || obj === void 0 ? void 0 : obj.isOk) !== 'function' &&
                typeof (obj === null || obj === void 0 ? void 0 : obj.isErr) !== 'function') {
                throwUnexpectedType();
            }
            if (obj.isErr()) {
                encoder.writeU8(0);
                abiEncode(errTy, obj.unwrapErr(), encoder);
            }
            else if (obj.isOk()) {
                encoder.writeU8(1);
                abiEncode(okTy, obj.unwrap(), encoder);
            }
        }
        else if (isSchemaArray(schema)) {
            // array
            const ty = schema[0];
            let count = schema[1];
            if (count === Number.POSITIVE_INFINITY) {
                count = obj.length;
                encoder.writeU32(count);
            }
            else if (obj.length !== count) {
                throw new Error(`expected \`${stringifySchema(schema)}\`, but had length ${obj.length}.`);
            }
            if (Array.isArray(obj)) {
                for (const item of obj) {
                    doAbiEncode(ty, item, encoder);
                }
                return;
            }
            if (!buffer_1.Buffer.isBuffer(obj) && typedArraySchemaType(obj) !== ty) {
                throwUnexpectedType();
            }
            if (ty == 'u8') {
                encoder.writeU8Array(obj);
            }
            else if (ty == 'i8') {
                encoder.writeI8Array(obj);
            }
            else if (ty == 'u16') {
                encoder.writeU16Array(obj);
            }
            else if (ty == 'i16') {
                encoder.writeI16Array(obj);
            }
            else if (ty == 'u32') {
                encoder.writeU32Array(obj);
            }
            else if (ty == 'i32') {
                encoder.writeI32Array(obj);
            }
            else if (ty == 'u64') {
                encoder.writeU64Array(obj);
            }
            else if (ty == 'i64') {
                encoder.writeI64Array(obj);
            }
            else if (ty == 'f32') {
                encoder.writeF32Array(obj);
            }
            else if (ty == 'f64') {
                encoder.writeF64Array(obj);
            }
            else {
                /* istanbul ignore next */
                throwUnexpectedType();
            }
        }
        else if (assertSchemaIsTuple(schema)) {
            // tuple
            if (!Array.isArray(obj)) {
                throwUnexpectedType();
            }
            else if (obj.length !== schema.length) {
                throw new Error(`incorrect tuple size for \`${JSON.stringify(schema)}\`. expected ${schema.length} but got ${obj.length}.`);
            }
            for (let i = 0; i < schema.length; i++) {
                doAbiEncode(schema[i], obj[i], encoder);
            }
        }
        else {
            /* istanbul ignore next */
            utils_1.unreachable(schema, `unknown schema: \`${schema}\``);
        }
    }
    else if (typeof (obj === null || obj === void 0 ? void 0 : obj.abiEncode) === 'function') {
        return obj.abiEncode(encoder);
    }
    else {
        /* istanbul ignore next */
        throw new Error(`invalid object for schema: expected \`${(_f = (_d = (_c = schema) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : (_e = schema === null || schema === void 0 ? void 0 : schema.constructor) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : JSON.stringify(schema)}\`, but got \`${JSON.stringify(obj)}\`.`);
    }
}
/**
 * Decodes an ABI-encoded object according to the provided schema.
 * @returns the previously encoded object
 */
function abiDecode(schema, bytes) {
    const decoder = bytes instanceof Decoder ? bytes : new Decoder(bytes);
    let obj;
    try {
        obj = doAbiDecode(schema, decoder);
        const remainder = decoder.remainder();
        if (remainder.length !== 0 && !(bytes instanceof Decoder)) {
            throw new Error(`failed to decode ${remainder.length} trailing bytes.`);
        }
    }
    catch (e) {
        const inputHex = utils_1.encodeHex(new Uint8Array(bytes instanceof Decoder ? [...bytes.buf] : [...bytes]));
        throw new Error(`abiDecode failed to interpret "${inputHex}" as ${stringifySchema(schema)}: ${e}`);
    }
    return obj;
}
exports.abiDecode = abiDecode;
function doAbiDecode(schema, bytes) {
    var _a;
    const decoder = bytes instanceof Decoder ? bytes : new Decoder(bytes);
    if (typeof schema === 'string') {
        const ty = schema;
        if (ty === 'void')
            return undefined;
        if (ty === 'boolean')
            return decoder.readBoolean();
        if (ty === 'u8')
            return decoder.readU8();
        if (ty === 'i8')
            return decoder.readI8();
        if (ty === 'u16')
            return decoder.readU16();
        if (ty === 'i16')
            return decoder.readI16();
        if (ty === 'u32')
            return decoder.readU32();
        if (ty === 'i32')
            return decoder.readI32();
        if (ty === 'u64')
            return decoder.readU64();
        if (ty === 'i64')
            return decoder.readI64();
        if (ty === 'f32')
            return decoder.readF32();
        if (ty === 'f64')
            return decoder.readF64();
        if (ty === 'u128')
            return decoder.readU128();
        if (ty === 'i128')
            return decoder.readI128();
        if (ty === 'string')
            return decoder.readString();
        utils_1.unreachable(ty, `unknown schema type: \`${ty}\``);
    }
    else if (Array.isArray(schema)) {
        if (schema[0] === 'Map') {
            const [_, keyTy, valTy] = schema;
            const length = decoder.readU32();
            const m = new types_1.OasisMap();
            for (let i = 0; i < length; i++) {
                m.set(doAbiDecode(keyTy, decoder), doAbiDecode(valTy, decoder));
            }
            return m;
        }
        if (schema[0] === 'Set') {
            const ty = schema[1];
            const length = decoder.readU32();
            const s = new types_1.OasisSet();
            for (let i = 0; i < length; i++) {
                s.add(doAbiDecode(ty, decoder));
            }
            return s;
        }
        if (schema[0] === 'Option') {
            return decoder.readBoolean()
                ? doAbiDecode(schema[1], decoder)
                : undefined;
        }
        if (schema[0] === 'Result') {
            return decoder.readBoolean()
                ? new types_1.Result.Ok(doAbiDecode(schema[1], decoder))
                : new types_1.Result.Err(doAbiDecode(schema[2], decoder));
        }
        // array
        if (isSchemaArray(schema)) {
            const ty = schema[0];
            const count = schema[1] === Number.POSITIVE_INFINITY
                ? decoder.readU32()
                : schema[1];
            if (ty === 'u8')
                return decoder.readU8Array(count);
            if (ty === 'i8')
                return decoder.readI8Array(count);
            if (ty === 'u16')
                return decoder.readU16Array(count);
            if (ty === 'i16')
                return decoder.readI16Array(count);
            if (ty === 'u32')
                return decoder.readU32Array(count);
            if (ty === 'i32')
                return decoder.readI32Array(count);
            if (ty === 'u64')
                return decoder.readU64Array(count);
            if (ty === 'i64')
                return decoder.readI64Array(count);
            if (ty === 'f32')
                return decoder.readF32Array(count);
            if (ty === 'f64')
                return decoder.readF64Array(count);
            const arr = [];
            for (let i = 0; i < count; i++) {
                arr[i] = doAbiDecode(ty, decoder);
            }
            return arr;
        }
        // tuple
        if (assertSchemaIsTuple(schema)) {
            return schema.map((s) => doAbiDecode(s, decoder));
        }
        /* istanbul ignore next */
        utils_1.unreachable(schema, `unknown schema: \`${schema}\``);
    }
    else if (typeof ((_a = schema) === null || _a === void 0 ? void 0 : _a.abiDecode) === 'function') {
        return schema.abiDecode(decoder);
    }
    else {
        /* istanbul ignore next */
        throw new Error(`invalid schema: ${JSON.stringify(schema)}`);
    }
}
exports.doAbiDecode = doAbiDecode;
/**
 * Encodes primitive values according to the Oasis ABI.
 *
 * You should prefer to use the top-level `abiEncode` function, but here's
 * an example of using `Encoder`, if you're really curious:
 * Example:
 * ```
 * const enc = new Encoder();
 * enc.writeU8(42);
 * enc.writeString('a string');
 * const buf = enc.finish();
 * ```
 */
class Encoder {
    constructor() {
        this.buf = buffer_1.Buffer.alloc(Encoder.INITIAL_BUF_SIZE);
        this.offset = 0;
    }
    reserveCapacity(extraCapacity) {
        const capacity = this.buf.length - this.offset;
        if (capacity < extraCapacity) {
            const prevBuf = this.buf;
            this.buf = buffer_1.Buffer.allocUnsafe(Math.max(Math.ceil(this.buf.length * Encoder.GROWTH_FACTOR), this.buf.length + extraCapacity));
            prevBuf.copy(this.buf);
            this.buf.fill(0, prevBuf.length);
        }
    }
    writeNumber(writer, byteWidth, num) {
        this.reserveCapacity(byteWidth);
        writer.call(this.buf, num, this.offset);
        this.offset += byteWidth;
    }
    writeBoolean(bool) {
        this.writeU8(Number(bool));
    }
    writeU8(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeUInt8, 1, num);
    }
    writeI8(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeInt8, 1, num);
    }
    writeU16(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeUInt16LE, 2, num);
    }
    writeI16(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeInt16LE, 2, num);
    }
    writeU32(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeUInt32LE, 4, num);
    }
    writeI32(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeInt32LE, 4, num);
    }
    writeU64(num) {
        // allow input of x: -1 < x < Number.MAX_VALUE
        this.writeBigUInt64LE(num, BigInt('-1'), BigInt(Number.MAX_VALUE));
    }
    writeI64(num) {
        // allow input of x: Number.MIN_SAFE_INTEGER < x < Number.MAX_VALUE
        this.writeBigUInt64LE(num, BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_VALUE));
    }
    /* istanbul ignore next */
    writeU128(_num) {
        throw new Error('unimplemented: u128');
    }
    /* istanbul ignore next */
    writeI128(_num) {
        throw new Error('unimplemented: i128');
    }
    writeF32(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeFloatLE, 4, num);
    }
    writeF64(num) {
        this.writeNumber(buffer_1.Buffer.prototype.writeDoubleLE, 8, num);
    }
    /** Writes a little-endian byte array. */
    writeNumericArray(arr) {
        const arrBuf = utils_1.typedArrayToBuffer(arr);
        this.reserveCapacity(arrBuf.length);
        arrBuf.copy(this.buf, this.offset);
        this.offset += arrBuf.length;
    }
    // TODO: Refactor to feross
    // https://github.com/feross/buffer/pull/267
    /** Write a little-endian unsigned BigInt
     * max and min are non-inclusive bounds
     */
    writeBigUInt64LE(value, min, max = BigInt(Number.MAX_VALUE)) {
        if (value >= max || value <= min)
            throw new Error(`trying to write value: ${value} out of range`);
        let lo = Number(value & BigInt('0xffffffff'));
        this.buf[this.offset++] = lo;
        lo = lo >> 8;
        this.buf[this.offset++] = lo;
        lo = lo >> 8;
        this.buf[this.offset++] = lo;
        lo = lo >> 8;
        this.buf[this.offset++] = lo;
        const divisor = BigInt(Math.pow(2, 32));
        const rounder = value < BigInt(0) ? -divisor + BigInt(-1) : BigInt(0);
        let hi = Number(((value + rounder) / divisor) & BigInt('0xffffffff'));
        this.buf[this.offset++] = hi;
        hi = hi >> 8;
        this.buf[this.offset++] = hi;
        hi = hi >> 8;
        this.buf[this.offset++] = hi;
        hi = hi >> 8;
        this.buf[this.offset++] = hi;
    }
    /** Writes a fixed-length `Uint8Array` */
    writeU8Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Int8Array` */
    writeI8Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Uint16Array` */
    writeU16Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Int16Array` */
    writeI16Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Uint32Array` */
    writeU32Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Int32Array` */
    writeI32Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `BigUint64Array` */
    writeU64Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `BigInt64Array` */
    writeI64Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Float32Array` */
    writeF32Array(arr) {
        this.writeNumericArray(arr);
    }
    /** Writes a fixed-length `Float64Array` */
    writeF64Array(arr) {
        this.writeNumericArray(arr);
    }
    writeString(str) {
        const encodedStr = buffer_1.Buffer.from(str);
        this.writeU32(encodedStr.length);
        this.reserveCapacity(encodedStr.length);
        this.offset += this.buf.write(str, this.offset);
    }
    finish() {
        return this.buf.subarray(0, this.offset);
    }
}
exports.Encoder = Encoder;
Encoder.INITIAL_BUF_SIZE = 256;
Encoder.GROWTH_FACTOR = 1.5;
/**
 * Decodes primitive values according to the Oasis ABI.
 *
 * You should prefer to use the top-level `abiDecode` function, but here's
 * an example of using `Decoder`, if you're really curious:
 * Example:
 * ```
 * const dec = new Decoder(new Uint8Array([1, 2, 3, 4]);
 * const buf = dec.readU8Array(4);
 * ```
 */
class Decoder {
    constructor(bytes) {
        this.offset = 0;
        this.buf = buffer_1.Buffer.isBuffer(bytes) ? bytes : utils_1.typedArrayToBuffer(bytes);
    }
    readBoolean() {
        return this.readU8() !== 0;
    }
    readU8() {
        const u8 = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return u8;
    }
    readI8() {
        const i8 = this.buf.readInt8(this.offset);
        this.offset += 1;
        return i8;
    }
    readU16() {
        const u16 = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return u16;
    }
    readI16() {
        const i16 = this.buf.readInt16LE(this.offset);
        this.offset += 2;
        return i16;
    }
    readU32() {
        const u32 = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return u32;
    }
    readI32() {
        const i32 = this.buf.readInt32LE(this.offset);
        this.offset += 4;
        return i32;
    }
    readU64() {
        const u64 = this.readBigUInt64LE(this.offset);
        this.offset += 8;
        return u64;
    }
    readI64() {
        const i64 = this.readBigInt64LE(this.offset);
        this.offset += 8;
        return i64;
    }
    /* istanbul ignore next */
    readU128() {
        throw new Error('unimplemented: u128');
    }
    /* istanbul ignore next */
    readI128() {
        throw new Error('unimplemented: i128');
    }
    readF32() {
        const f32 = this.buf.readFloatLE(this.offset);
        this.offset += 4;
        return f32;
    }
    readF64() {
        const f64 = this.buf.readDoubleLE(this.offset);
        this.offset += 8;
        return f64;
    }
    readNumericArray(typedArray, length) {
        const numBytes = length * typedArray.BYTES_PER_ELEMENT;
        const arrBuf = buffer_1.Buffer.alloc(numBytes);
        this.buf.copy(arrBuf, 0, this.offset, this.offset + numBytes);
        const arr = new typedArray(arrBuf.buffer, arrBuf.byteOffset, length);
        this.offset += numBytes;
        return arr;
    }
    // TODO: Refactor to feross
    // https://github.com/feross/buffer/pull/267
    /** Read a little-endian unsigned BigInt */
    readBigUInt64LE(offset = 0) {
        if (this.buf.readBigUInt64LE) {
            return this.buf.readBigUInt64LE(this.offset);
        }
        const first = this.buf[offset];
        const last = this.buf[offset + 7];
        if (first === undefined || last === undefined)
            throw new Error('buffer bound error');
        const lo = first +
            this.buf[++offset] * Math.pow(2, 8) +
            this.buf[++offset] * Math.pow(2, 16) +
            this.buf[++offset] * Math.pow(2, 24);
        const hi = this.buf[++offset] +
            this.buf[++offset] * Math.pow(2, 8) +
            this.buf[++offset] * Math.pow(2, 16) +
            last * Math.pow(2, 24);
        return BigInt(lo) + BigInt(hi) * BigInt(Math.pow(2, 32));
    }
    // TODO: Refactor to feross
    // https://github.com/feross/buffer/pull/267
    /** Read a little-endian signed BigInt */
    readBigInt64LE(offset = 0) {
        if (this.buf.readBigInt64LE) {
            return this.buf.readBigInt64LE(this.offset);
        }
        const first = this.buf[offset];
        const last = this.buf[offset + 7];
        if (first === undefined || last === undefined)
            throw new Error('buffer bound error');
        const hi = this.buf[offset + 4] +
            this.buf[offset + 5] * Math.pow(2, 8) +
            this.buf[offset + 6] * Math.pow(2, 16) +
            (last << 24); // Overflow
        const lo = first +
            this.buf[++offset] * Math.pow(2, 8) +
            this.buf[++offset] * Math.pow(2, 16) +
            this.buf[++offset] * Math.pow(2, 24);
        return BigInt(lo) + BigInt(hi) * BigInt(Math.pow(2, 32));
    }
    readU8Array(length) {
        return this.readNumericArray(Uint8Array, length);
    }
    readI8Array(length) {
        return this.readNumericArray(Int8Array, length);
    }
    readU16Array(length) {
        return this.readNumericArray(Uint16Array, length);
    }
    readI16Array(length) {
        return this.readNumericArray(Int16Array, length);
    }
    readU32Array(length) {
        return this.readNumericArray(Uint32Array, length);
    }
    readI32Array(length) {
        return this.readNumericArray(Int32Array, length);
    }
    readU64Array(length) {
        return this.readNumericArray(BigUint64Array, length);
    }
    readI64Array(length) {
        return this.readNumericArray(BigInt64Array, length);
    }
    readF32Array(length) {
        return this.readNumericArray(Float32Array, length);
    }
    readF64Array(length) {
        return this.readNumericArray(Float64Array, length);
    }
    readString() {
        const length = this.readU32();
        const str = this.buf.toString('utf8', this.offset, this.offset + length);
        this.offset += length;
        return str;
    }
    remainder() {
        return this.buf.subarray(this.offset);
    }
}
exports.Decoder = Decoder;
const TYPED_ARRAY_RE = /^\[object (Uint|Int|Float|BigInt|BigUint)(8|16|32|64)(?:Clamped)?Array\]$/;
function typedArraySchemaType(obj) {
    const tag = Object.prototype.toString.call(obj);
    const match = TYPED_ARRAY_RE.exec(tag);
    /* istanbul ignore next */
    if (match === null) {
        return null;
    }
    const [_, ty, bitWidth] = match;
    let tyLetter;
    if (ty === 'Uint' || ty === 'BigUint') {
        tyLetter = 'u';
    }
    else if (ty === 'Int' || ty === 'BigInt') {
        tyLetter = 'i';
    }
    else {
        tyLetter = 'f';
    }
    return tyLetter + bitWidth;
}
exports.typedArraySchemaType = typedArraySchemaType;
/**
 * Returns the 32-byte hex-encoded string that represents an object in event topic form.
 */
function encodeEventTopic(schema, topic) {
    const TOPIC_LEN = 32;
    const repr = abiEncode(schema, topic);
    if (repr.length <= TOPIC_LEN) {
        return repr.toString('hex').padEnd(TOPIC_LEN * 2, '0');
    }
    else {
        return js_sha3_1.keccak256(repr);
    }
}
exports.encodeEventTopic = encodeEventTopic;
//# sourceMappingURL=abi.js.map