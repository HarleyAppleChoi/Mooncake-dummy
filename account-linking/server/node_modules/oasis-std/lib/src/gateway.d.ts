import EventEmitter from 'eventemitter3';
import { Address, Balance } from './types';
/**
 * The `Gateway` class allows clients to make requests of the Oasis Developer Gateway.
 */
export declare class Gateway {
    readonly url: string;
    readonly apiToken: string;
    readonly headers: Map<string, string>;
    private inner;
    private keyStore;
    private subscriptionId;
    private log;
    constructor(url: string, apiToken: string, headers?: Map<string, string>);
    /**
     * Deploy a new confidential service.
     * `payload` should be the service bytecode followed by the constructor stdin.
     * @returns a promise that resolves to the address of the newly-created service.
     */
    deploy(payload: Uint8Array, options?: DeployOptions): Promise<Address>;
    static makeDeployCode(payload: Uint8Array, options?: DeployOptions): Uint8Array;
    /**
     * Calls a confidential service deployed at `address` with `payload` as stdin.
     * Optional `headers` override those passed to the `Gateway` constructor.
     * @returns a promise that resolves to the service stdout or rejects with an `RpcError`.
     */
    rpc(address: Address, payload: Uint8Array, options?: RpcOptions, headers?: Map<string, string>): Promise<Uint8Array>;
    /**
     * Monkey-patches the headers on the inner `HttpGateway` for a single request, `req`.
     * The code in `req` must be  entirely synchronous to ensure that the additional headers
     * are unset in time for the next request.
     */
    private withHeaders;
    private static convertError;
    /**
     * Subscribes to events emitted by the service at `address` that contain
     * all of the provided `topics` and for which `filter` returns true.
     */
    subscribe<T>(address: Address | null, topics: string[], decoder: (payload: Uint8Array) => Promise<T>, filter?: (event: T) => boolean): Promise<Subscription<T>>;
    /**
     * Cancels a previous subscription named `subscriptionName`.
     */
    private unsubscribe;
    /**
     * @returns a promise that resolves to the bytecode present at `address`. Rejects
     * if there is no service at `address` or there is no bytecode (i.e. the address is an
     * externally-owned account).
     */
    getCode(address: Address): Promise<Uint8Array>;
    /**
     * @returns a promise that resolves to the public key of the service at `address`.
     * Rejects if there is no service at `address`.
     */
    getPublicKey(address: Address): Promise<Uint8Array>;
    /**
     * Returns the expiry timestamp (in seconds) of the service at `address`, if it exists.
     */
    getExpiry(address: Address): Promise<number>;
    /**
     * Disconnects this gateway from the backend server.
     */
    disconnect(): Promise<void>;
}
export declare type RpcOptions = {
    aad?: Uint8Array;
    value?: Balance;
    gasLimit?: string | number;
};
export declare type DeployOptions = RpcOptions & {
    expiry?: number;
};
/**
 * A class that represents an event-emiting object (with `.on(...)` API)
 * as an async iterable (with `for await (... of ...)` API).
 * It also provides hooks for event transformation (e.g. ABI decoding) and filtering.
 */
export declare class Subscription<T> implements AsyncIterable<T> {
    private name;
    private gateway;
    private events;
    private hasResults;
    /**
     * @param name The event to listen to from `emitter`.
     * @param emitter Events from this object will be exposed.
     * @param decoder Each event will be deserialized with this function before being exposed.
     * @param filter Only events for which the filter returns true (after deserialization) will be exposed.
     * @param gateway Once the output iterator terminates, we'll unsubscribe from events from this gateway.
     *                The assumption is that `emitter` generates events from `gateway`.
     */
    constructor(name: string, emitter: EventEmitter, decoder: (payload: Uint8Array) => Promise<T>, filter: (event: T) => boolean, gateway: Gateway);
    [Symbol.asyncIterator](): AsyncIterator<T>;
    first(): Promise<T>;
}
