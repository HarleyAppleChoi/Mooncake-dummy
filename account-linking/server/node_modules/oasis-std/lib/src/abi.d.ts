/// <reference types="node" />
export interface AbiEncodable {
    /** Encodes a struct or enum object using the provided ABI `Encoder`. */
    abiEncode(encoder: Encoder): void;
}
export interface AbiDecodable {
    /** Decodes a struct or enum object using the provided ABI `Decoder`. */
    abiDecode(decoder: Decoder): any;
}
/**
 * The ABI format is not self-describing, for efficiency. Thus, (en|de)coding requires
 * the schema present. You will generally not have to construct schemas directly since
 * (en|de)coding methods will be auto-generated for your types.
 */
export declare type Schema = 'void' | 'u8' | 'i8' | 'u16' | 'i16' | 'u32' | 'i32' | 'u64' | 'i64' | 'u128' | 'i128' | 'f32' | 'f64' | 'boolean' | 'string' | [Schema, number] | Schema[] | ['Set', Schema] | ['Map', Schema, Schema] | ['Option', Schema] | ['Result', Schema, Schema] | AbiEncodable | AbiDecodable;
/**
 * ABI encodes an object according to the provided schema.
 * @returns the encoded bytes
 */
export declare function abiEncode(schema: Schema, obj: any, encoder?: Encoder): Buffer;
/**
 * Decodes an ABI-encoded object according to the provided schema.
 * @returns the previously encoded object
 */
export declare function abiDecode(schema: Schema, bytes: Uint8Array | Buffer | Decoder): any;
export declare function doAbiDecode(schema: Schema, bytes: Uint8Array | Buffer | Decoder): any;
/**
 * Encodes primitive values according to the Oasis ABI.
 *
 * You should prefer to use the top-level `abiEncode` function, but here's
 * an example of using `Encoder`, if you're really curious:
 * Example:
 * ```
 * const enc = new Encoder();
 * enc.writeU8(42);
 * enc.writeString('a string');
 * const buf = enc.finish();
 * ```
 */
export declare class Encoder {
    static INITIAL_BUF_SIZE: number;
    static GROWTH_FACTOR: number;
    private buf;
    private offset;
    reserveCapacity(extraCapacity: number): void;
    writeNumber<T>(writer: (num: T, offset: number) => void, byteWidth: number, num: T): void;
    writeBoolean(bool: boolean): void;
    writeU8(num: number): void;
    writeI8(num: number): void;
    writeU16(num: number): void;
    writeI16(num: number): void;
    writeU32(num: number): void;
    writeI32(num: number): void;
    writeU64(num: bigint): void;
    writeI64(num: bigint): void;
    writeU128(_num: bigint): void;
    writeI128(_num: bigint): void;
    writeF32(num: number): void;
    writeF64(num: number): void;
    /** Writes a little-endian byte array. */
    private writeNumericArray;
    /** Write a little-endian unsigned BigInt
     * max and min are non-inclusive bounds
     */
    private writeBigUInt64LE;
    /** Writes a fixed-length `Uint8Array` */
    writeU8Array(arr: Uint8Array | Uint8ClampedArray): void;
    /** Writes a fixed-length `Int8Array` */
    writeI8Array(arr: Int8Array): void;
    /** Writes a fixed-length `Uint16Array` */
    writeU16Array(arr: Uint16Array): void;
    /** Writes a fixed-length `Int16Array` */
    writeI16Array(arr: Int16Array): void;
    /** Writes a fixed-length `Uint32Array` */
    writeU32Array(arr: Uint32Array): void;
    /** Writes a fixed-length `Int32Array` */
    writeI32Array(arr: Int32Array): void;
    /** Writes a fixed-length `BigUint64Array` */
    writeU64Array(arr: BigUint64Array): void;
    /** Writes a fixed-length `BigInt64Array` */
    writeI64Array(arr: BigInt64Array): void;
    /** Writes a fixed-length `Float32Array` */
    writeF32Array(arr: Float32Array): void;
    /** Writes a fixed-length `Float64Array` */
    writeF64Array(arr: Float64Array): void;
    writeString(str: string): void;
    finish(): Buffer;
}
/**
 * Decodes primitive values according to the Oasis ABI.
 *
 * You should prefer to use the top-level `abiDecode` function, but here's
 * an example of using `Decoder`, if you're really curious:
 * Example:
 * ```
 * const dec = new Decoder(new Uint8Array([1, 2, 3, 4]);
 * const buf = dec.readU8Array(4);
 * ```
 */
export declare class Decoder {
    private buf;
    private offset;
    constructor(bytes: Buffer | Uint8Array);
    readBoolean(): boolean;
    readU8(): number;
    readI8(): number;
    readU16(): number;
    readI16(): number;
    readU32(): number;
    readI32(): number;
    readU64(): bigint;
    readI64(): bigint;
    readU128(): bigint;
    readI128(): bigint;
    readF32(): number;
    readF64(): number;
    private readNumericArray;
    /** Read a little-endian unsigned BigInt */
    private readBigUInt64LE;
    /** Read a little-endian signed BigInt */
    private readBigInt64LE;
    readU8Array(length: number): Uint8Array;
    readI8Array(length: number): Int16Array;
    readU16Array(length: number): Uint16Array;
    readI16Array(length: number): Int16Array;
    readU32Array(length: number): Uint32Array;
    readI32Array(length: number): Int32Array;
    readU64Array(length: number): BigUint64Array;
    readI64Array(length: number): BigInt64Array;
    readF32Array(length: number): Float32Array;
    readF64Array(length: number): Float64Array;
    readString(): string;
    remainder(): Buffer;
}
export declare function typedArraySchemaType(obj: any): string | null;
/**
 * Returns the 32-byte hex-encoded string that represents an object in event topic form.
 */
export declare function encodeEventTopic(schema: Schema, topic: any): string;
